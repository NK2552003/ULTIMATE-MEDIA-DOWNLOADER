#!/usr/bin/env python3
"""
Ultimate Multi-Platform Media Downloader
Supports YouTube, Spotify, Apple Music, SoundCloud, and 1000+ other platforms
"""

import os
import sys
import argparse
import json
import time
import threading
import re
from pathlib import Path
from datetime import datetime
from urllib.parse import urlparse, parse_qs
import signal

import yt_dlp
import requests
from concurrent.futures import ThreadPoolExecutor, TimeoutError
import subprocess
import shutil
from PIL import Image
import io

try:
    import spotipy
    from spotipy.oauth2 import SpotifyClientCredentials
    SPOTIFY_AVAILABLE = True
except ImportError:
    SPOTIFY_AVAILABLE = False

try:
    import mutagen
    from mutagen.flac import FLAC, Picture
    from mutagen.mp3 import MP3
    from mutagen.id3 import ID3, APIC, TIT2, TPE1, TALB, TDRC
    from mutagen.mp4 import MP4, MP4Cover
    from mutagen.wave import WAVE
    MUTAGEN_AVAILABLE = True
except ImportError:
    MUTAGEN_AVAILABLE = False

try:
    from youtubesearchpython import VideosSearch
    YOUTUBE_SEARCH_AVAILABLE = True
except ImportError:
    YOUTUBE_SEARCH_AVAILABLE = False

try:
    import gamdl
    from gamdl.downloader import Downloader as GamdlDownloader
    GAMDL_AVAILABLE = True
except ImportError:
    GAMDL_AVAILABLE = False

try:
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from webdriver_manager.chrome import ChromeDriverManager
    import undetected_chromedriver as uc
    SELENIUM_AVAILABLE = True
except ImportError:
    SELENIUM_AVAILABLE = False

try:
    import cloudscraper
    CLOUDSCRAPER_AVAILABLE = True
except ImportError:
    CLOUDSCRAPER_AVAILABLE = False

try:
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn, DownloadColumn, TransferSpeedColumn
    from rich.panel import Panel
    from rich.table import Table
    from rich.text import Text
    from rich import box
    from rich.live import Live
    from rich.layout import Layout
    from rich.align import Align
    from rich.style import Style
    from rich.markdown import Markdown
    from rich.prompt import Prompt, Confirm
    from rich.columns import Columns
    from rich.tree import Tree
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False

try:
    import emoji
    EMOJI_AVAILABLE = True
except ImportError:
    EMOJI_AVAILABLE = False

try:
    from pyfiglet import Figlet
    PYFIGLET_AVAILABLE = True
except ImportError:
    PYFIGLET_AVAILABLE = False

try:
    from halo import Halo
    HALO_AVAILABLE = True
except ImportError:
    HALO_AVAILABLE = False


class QuietLogger:
    """Custom logger to suppress yt-dlp's verbose output"""
    
    def debug(self, msg):
        # Suppress debug messages
        pass
    
    def info(self, msg):
        # Only show important info messages
        if msg.startswith('[download]'):
            # Suppress download progress lines (we have our own)
            if 'Downloading' in msg and 'item' in msg:
                # Show "Downloading item X of Y" messages
                if RICH_AVAILABLE:
                    from rich.console import Console
                    console = Console()
                    console.print(f"[dim cyan]{msg}[/dim cyan]")
                else:
                    print(msg)
        elif msg.startswith('[info]'):
            # Suppress info messages about downloading thumbnails, etc.
            pass
        elif 'Sleeping' in msg:
            # Suppress "Sleeping X seconds" messages
            pass
        else:
            # Show other important messages
            pass
    
    def warning(self, msg):
        # Show warnings
        if RICH_AVAILABLE:
            from rich.console import Console
            console = Console()
            console.print(f"[yellow]‚ö†[/yellow] {msg}")
        else:
            print(f"‚ö† {msg}")
    
    def error(self, msg):
        # Show errors
        if RICH_AVAILABLE:
            from rich.console import Console
            console = Console()
            console.print(f"[bold red]‚úó[/bold red] {msg}")
        else:
            print(f"‚úó {msg}")


class Icons:
    """Modern 2D icon management with flat design emojis"""
    
    @staticmethod
    def get(name):
        """Get modern flat design icons"""
        icon_map = {
            # Status icons - using flat 2D style
            'success': '‚úì', 'error': '‚úó', 'warning': '‚ö†', 'info': '‚Ñπ', 'tip': 'üí°',
            
            # Media icons - minimal flat design
            'video': '‚ñ∂', 'audio': '‚ô´', 'music': '‚ô™', 'playlist': '‚â°', 'download': '‚Üì',
            'folder': 'üìÇ', 'link': 'üîó', 'search': 'üîç',
            
            # Platform icons - recognizable symbols
            'youtube': '‚ñ∂', 'spotify': '‚ô™', 'soundcloud': '‚òÅ', 'instagram': 'üì∑',
            'tiktok': '‚ô™', 'twitter': 'üê¶', 'facebook': 'f',
            
            # Progress icons
            'loading': '‚ü≥', 'processing': '‚öô', 'completed': '‚úì', 'failed': '‚úó',
            
            # Quality icons
            'hd': '‚ö°', 'quality': '‚òÖ', 'format': 'üìÑ',
            
            # Action icons
            'start': '‚ñ∏', 'stop': '‚ñ†', 'pause': '‚è∏', 'play': '‚ñ∂',
            
            # Statistics
            'stats': 'üìä', 'count': '#', 'time': '‚è±', 'speed': '‚ö°',
            
            # Social
            'like': '‚ô•', 'views': 'üëÅ', 'channel': 'üë§',
            
            # Misc
            'world': 'ÔøΩ', 'book': 'ÔøΩ', 'target': 'üéØ', 'sparkles': '‚ú®',
            'fire': 'üî•', 'package': 'üì¶', 'art': 'üé®', 'game': 'üéÆ', 'phone': 'üì±',
        }
        return icon_map.get(name, '‚Ä¢')


class Messages:
    """Centralized message templates with Rich formatting"""
    
    @staticmethod
    def success(text):
        return f"[bold green]{Icons.get('success')} {text}[/bold green]"
    
    @staticmethod
    def error(text):
        return f"[bold red]{Icons.get('error')} {text}[/bold red]"
    
    @staticmethod
    def warning(text):
        return f"[bold yellow]{Icons.get('warning')} {text}[/bold yellow]"
    
    @staticmethod
    def info(text):
        return f"[cyan]{Icons.get('info')} {text}[/cyan]"
    
    @staticmethod
    def tip(text):
        return f"[bold magenta]{Icons.get('tip')} {text}[/bold magenta]"
    
    @staticmethod
    def downloading(text):
        return f"[bold blue]{Icons.get('download')} {text}[/bold blue]"
    
    @staticmethod
    def searching(text):
        return f"[bold cyan]{Icons.get('search')} {text}[/bold cyan]"
    
    @staticmethod
    def processing(text):
        return f"[bold yellow]{Icons.get('processing')} {text}[/bold yellow]"
    
    @staticmethod
    def completed(text):
        return f"[bold green]{Icons.get('completed')} {text}[/bold green]"


class ModernUI:
    """Professional CLI UI with animations and modern design"""
    
    def __init__(self):
        self.console = Console() if RICH_AVAILABLE else None
        
    def clear_screen(self):
        """Clear terminal screen"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def create_ascii_logo(self):
        """Create ASCII art logo"""
        if PYFIGLET_AVAILABLE:
            fig = Figlet(font='slant', width=80)
            return fig.renderText('DOWNLOADER')
        else:
            return """
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
"""
    
    def show_welcome_banner(self):
        """Display professional welcome banner"""
        if not RICH_AVAILABLE or not self.console:
            return
        
        self.clear_screen()
        
        # Create gradient text for logo
        logo_text = Text()
        logo_lines = self.create_ascii_logo().strip().split('\n')
        
        for line in logo_lines:
            logo_text.append(line + '\n', style="bold cyan")
        
        # Create main panel
        content = Align.center(logo_text)
        
        panel = Panel(
            content,
            border_style="bright_cyan",
            box=box.DOUBLE,
            padding=(1, 2),
            title="[bold white]üé¨ ULTIMATE MEDIA DOWNLOADER[/bold white]",
            subtitle="[dim]v2.0 - Professional Edition[/dim]"
        )
        
        self.console.print(panel)
        
        # Feature highlights in columns
        features = Table.grid(padding=(0, 2))
        features.add_column(justify="center", style="cyan")
        features.add_column(justify="center", style="magenta")
        features.add_column(justify="center", style="green")
        features.add_column(justify="center", style="yellow")
        
        features.add_row(
            "‚ñ∂ Video Downloads",
            "‚ô™ Audio Extraction", 
            "üì± Social Media",
            "‚ö° 1000+ Platforms"
        )
        
        self.console.print(Align.center(features))
        self.console.print()
    
    def show_interactive_banner(self):
        """Display interactive mode banner"""
        if not RICH_AVAILABLE or not self.console:
            print("\n‚ñ∂ Ultimate Media Downloader - Interactive Mode")
            print("=" * 70)
            return
        
        # Title with gradient effect
        title = Text()
        title.append("‚ñ∂  I N T E R A C T I V E   M O D E  ‚óÄ", style="bold yellow")
        
        # Create info table
        info_table = Table.grid(padding=(0, 2))
        info_table.add_column(style="cyan", justify="center")
        
        info_table.add_row("[bold white]Supported Platforms:[/bold white]")
        info_table.add_row("‚ñ∂ YouTube     ‚ô™ Spotify     ‚óâ Instagram")
        info_table.add_row("‚ô´ SoundCloud  ‚ñ≠ TikTok      ‚óê Twitter")
        info_table.add_row("... and 1000+ more!")
        info_table.add_row("")
        info_table.add_row("[bold white]Quick Commands:[/bold white]")
        info_table.add_row("[yellow]help[/yellow]      - Show available commands")
        info_table.add_row("[yellow]platforms[/yellow] - List supported sites")
        info_table.add_row("[yellow]quit[/yellow]      - Exit application")
        
        panel = Panel(
            Align.center(info_table),
            title=title,
            border_style="bright_magenta",
            box=box.ROUNDED,
            padding=(1, 2)
        )
        
        self.console.print(panel)
        self.console.print()
    
    def show_spinner(self, text, spinner_type='dots'):
        """Create and return a spinner for loading states"""
        if HALO_AVAILABLE:
            return Halo(text=text, spinner=spinner_type, color='cyan')
        return None
    
    def success_message(self, message):
        """Display success message"""
        if self.console:
            self.console.print(f"\n[bold green]‚úì[/bold green] {message}", style="green")
        else:
            print(f"\n‚úì {message}")
    
    def error_message(self, message):
        """Display error message"""
        if self.console:
            self.console.print(f"\n[bold red]‚úó[/bold red] {message}", style="red")
        else:
            print(f"\n‚úó {message}")
    
    def info_message(self, message):
        """Display info message"""
        if self.console:
            self.console.print(f"[cyan]‚Ñπ[/cyan] {message}")
        else:
            print(f"‚Ñπ {message}")
    
    def warning_message(self, message, show_icon=True):
        """Display warning message"""
        if self.console:
            icon = "‚ö† " if show_icon else ""
            self.console.print(f"[yellow]{icon}{message}[/yellow]")
        else:
            icon = "‚ö†Ô∏è " if show_icon else ""
            print(f"{icon}{message}")
    
    def prompt_input(self, prompt_text, default=None):
        """Prompt user for input with styling"""
        if self.console and RICH_AVAILABLE:
            return Prompt.ask(f"[bold cyan]üîó[/bold cyan] {prompt_text}", default=default)
        else:
            user_input = input(f"üîó {prompt_text}: ").strip()
            return user_input if user_input else default
    
    def create_download_progress(self):
        """Create a modern progress bar for downloads"""
        if RICH_AVAILABLE:
            return Progress(
                SpinnerColumn(spinner_name="dots"),
                TextColumn("[bold blue]{task.description}"),
                BarColumn(bar_width=40, style="cyan", complete_style="green"),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                DownloadColumn(),
                TransferSpeedColumn(),
                TimeRemainingColumn(),
                console=self.console,
                transient=False
            )
        return None


class UltimateMediaDownloader:
    def __init__(self, output_dir="downloads"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.cancelled = False
        
        # Initialize Rich console for beautiful output
        self.console = Console() if RICH_AVAILABLE else None
        self.current_progress = None
        
        # Platform-specific configurations
        self.platform_configs = {
            'youtube': {
                'extractors': ['youtube', 'youtu.be'],
                'formats': ['mp4', 'webm', 'mp3', 'wav', 'flac']
            },
            'spotify': {
                'extractors': ['spotify'],
                'formats': ['mp3', 'wav', 'flac'],
                'note': 'Spotify tracks will be searched on YouTube for download'
            },
            'soundcloud': {
                'extractors': ['soundcloud'],
                'formats': ['mp3', 'wav', 'flac']
            },
            'apple_music': {
                'extractors': ['apple', 'itunes'],
                'formats': ['mp3', 'wav', 'flac'],
                'note': 'Apple Music tracks will be searched on YouTube for download'
            },
            'generic': {
                'extractors': ['generic'],
                'formats': ['mp4', 'mp3', 'wav']
            }
        }
        
        # Enhanced yt-dlp configuration for maximum performance and quality
        self.default_ydl_opts = {
            # Performance optimizations
            'socket_timeout': 30,
            'retries': 10,
            'fragment_retries': 10,
            'skip_unavailable_fragments': True,
            'keepvideo': False,
            'noplaylist': False,
            'ignoreerrors': True,
            'no_warnings': True,  # Suppress warnings for cleaner output
            'quiet': True,  # Suppress yt-dlp's default progress output
            'no_color': False,  # Allow colors in our custom progress
            'extractaudio': False,
            'audioformat': 'best',  # Changed from 'mp3' to 'best' for higher quality
            'concurrent_fragments': 8,  # Enable parallel fragment downloads
            'http_chunk_size': 10485760,  # 10MB chunks for faster downloads
            
            # Quality settings for high-quality audio
            'prefer_free_formats': False,  # Prefer higher quality formats even if not free
            'format_sort': ['quality', 'res', 'fps', 'hdr:12', 'codec:vp9.2', 'size', 'br', 'asr', 'proto'],
            
            # File naming and organization
            'outtmpl': str(self.output_dir / '%(artist,uploader)s - %(title)s.%(ext)s'),
            
            # Metadata and cover art - write intermediate files but clean them later
            'writeinfojson': False,  # Don't keep JSON files
            'writethumbnail': True,  # Write thumbnail for embedding
            'writesubtitles': False,
            'writeautomaticsub': False,
            'subtitleslangs': ['en'],
            
            # Enhanced user agent for better compatibility
            'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
            
            # Cache for faster repeated operations
            'cachedir': str(self.output_dir / '.cache'),
            
            # Resume support
            'continue_dl': True,
            'part': True,
            
            # Custom logger to suppress verbose output
            'logger': QuietLogger(),
        }
        
        # Initialize Spotify client if available
        self.spotify_client = None
        if SPOTIFY_AVAILABLE:
            self._init_spotify()
        
        # Initialize Apple Music downloader if available
        self.apple_music_downloader = None
        if GAMDL_AVAILABLE:
            self._init_apple_music()
        
        # Initialize browser for enhanced scraping
        self.browser_driver = None
    
    def _init_spotify(self):
        """Initialize Spotify client (requires API credentials)"""
        try:
            # You would need to set these environment variables or provide them
            client_id = os.environ.get('SPOTIFY_CLIENT_ID')
            client_secret = os.environ.get('SPOTIFY_CLIENT_SECRET')
            
            if client_id and client_secret:
                client_credentials_manager = SpotifyClientCredentials(
                    client_id=client_id, 
                    client_secret=client_secret
                )
                self.spotify_client = spotipy.Spotify(
                    client_credentials_manager=client_credentials_manager
                )
                # Only show success in verbose mode
            # Suppress warnings by default - not critical for operation
        except Exception as e:
            # Only show errors in verbose mode
            pass
    
    def _init_apple_music(self):
        """Initialize Apple Music downloader"""
        try:
            # Check if Apple Music credentials are available
            apple_music_token = os.environ.get('APPLE_MUSIC_TOKEN')
            apple_music_storefront = os.environ.get('APPLE_MUSIC_STOREFRONT', 'us')
            
            if apple_music_token:
                # Initialize gamdl with token
                self.apple_music_downloader = GamdlDownloader(
                    token=apple_music_token,
                    storefront=apple_music_storefront
                )
                # Only show success in verbose mode
            # Suppress warnings - fallback to YouTube search works well
        except Exception as e:
            # Only show errors in verbose mode
            pass
    
    def _get_browser_driver(self):
        """Get or create browser driver for enhanced scraping"""
        # Skip browser automation - it's unreliable across platforms
        # Use enhanced HTTP scraping instead
        return None
    
    def print_rich(self, message, style="bold cyan"):
        """Print with Rich formatting if available, fallback to plain print"""
        if RICH_AVAILABLE and self.console:
            self.console.print(message, style=style)
        else:
            print(message)
    
    def print_panel(self, content, title=None, style="bold blue", border_style="cyan"):
        """Print a beautiful panel with Rich if available"""
        if RICH_AVAILABLE and self.console:
            self.console.print(Panel(content, title=title, style=style, border_style=border_style, box=box.ROUNDED))
        else:
            if title:
                print(f"\n{'='*60}")
                print(f"  {title}")
                print('='*60)
            print(content)
            print('='*60)
    
    def print_table(self, title, headers, rows, style="cyan"):
        """Print a beautiful table with Rich if available"""
        if RICH_AVAILABLE and self.console:
            table = Table(title=title, box=box.ROUNDED, style=style)
            for header in headers:
                table.add_column(header, style="bold")
            for row in rows:
                table.add_row(*[str(cell) for cell in row])
            self.console.print(table)
        else:
            print(f"\n{title}")
            print("-" * 60)
            print(" | ".join(headers))
            print("-" * 60)
            for row in rows:
                print(" | ".join(str(cell) for cell in row))
            print("-" * 60)
    
    def detect_platform(self, url):
        """Detect the platform from URL"""
        url_lower = url.lower()
        
        if any(domain in url_lower for domain in ['youtube.com', 'youtu.be', 'm.youtube.com']):
            return 'youtube'
        elif 'spotify.com' in url_lower:
            return 'spotify'
        elif 'soundcloud.com' in url_lower:
            return 'soundcloud'
        elif any(domain in url_lower for domain in ['music.apple.com', 'itunes.apple.com']):
            return 'apple_music'
        elif any(domain in url_lower for domain in ['tiktok.com', 'instagram.com', 'facebook.com', 'twitter.com', 'x.com']):
            return 'social_media'
        else:
            return 'generic'
    
    def get_supported_sites(self):
        """Get list of all supported sites"""
        try:
            # Return a curated list of major supported platforms
            # This avoids the internal API issue and provides cleaner output
            major_sites = [
                {'name': 'YouTube', 'description': 'YouTube videos, playlists, channels'},
                {'name': 'Spotify', 'description': 'Spotify tracks, albums, playlists (via YouTube search)'},
                {'name': 'SoundCloud', 'description': 'SoundCloud tracks and playlists'},
                {'name': 'TikTok', 'description': 'TikTok videos'},
                {'name': 'Instagram', 'description': 'Instagram posts, reels, IGTV'},
                {'name': 'Twitter', 'description': 'Twitter videos'},
                {'name': 'Facebook', 'description': 'Facebook videos'},
                {'name': 'Vimeo', 'description': 'Vimeo videos'},
                {'name': 'Twitch', 'description': 'Twitch VODs and clips'},
                {'name': 'Apple Music', 'description': 'Apple Music tracks (via YouTube search)'},
                {'name': 'Generic', 'description': '1000+ other video and audio platforms'}
            ]
            return major_sites
        except Exception as e:
            print(f"Error getting supported sites: {e}")
            return [{'name': 'Error', 'description': 'Could not load site list'}]
    
    def search_and_download_spotify_track(self, spotify_url):
        """Search for Spotify track/album/playlist on YouTube and download"""
        if not self.spotify_client:
            self.print_rich(Messages.error("Spotify API not available. Trying to extract track info from URL..."))
            return self._fallback_spotify_search(spotify_url)
        
        try:
            # Determine Spotify content type
            if '/track/' in spotify_url:
                return self._download_spotify_track(spotify_url)
            elif '/album/' in spotify_url:
                return self._download_spotify_album(spotify_url)
            elif '/playlist/' in spotify_url:
                return self._download_spotify_playlist(spotify_url)
            else:
                self.print_rich(Messages.error("Unknown Spotify URL format"))
                return None
                
        except Exception as e:
            self.print_rich(Messages.error(f"Error processing Spotify URL: {e}"))
            return self._fallback_spotify_search(spotify_url)
    
    def _download_spotify_track(self, spotify_url):
        """Download single Spotify track"""
        track_id = self._extract_spotify_id(spotify_url, 'track')
        if not track_id:
            return None
        
        track = self.spotify_client.track(track_id)
        artists = ', '.join([artist['name'] for artist in track['artists']])
        track_name = track['name']
        search_query = f"{artists} - {track_name}"
        
        self.print_rich(f"[bold green]{Icons.get('spotify')} Spotify Track:[/bold green] [cyan]{search_query}[/cyan]")
        self.print_rich(Messages.searching("Searching on YouTube..."))
        
        youtube_url = self._search_youtube(search_query)
        if youtube_url:
            self.print_rich(Messages.success(f"Found on YouTube: {youtube_url}"))
            # Use enhanced audio settings for Spotify tracks
            return self.download_media(
                youtube_url, 
                audio_only=True, 
                output_format='mp3',  # MP3 for better compatibility
                add_metadata=True,
                add_thumbnail=True
            )
        else:
            self.print_rich(Messages.error("Could not find track on YouTube"))
            return None
    
    def _download_spotify_album(self, spotify_url):
        """Download Spotify album by searching each track on YouTube"""
        album_id = self._extract_spotify_id(spotify_url, 'album')
        if not album_id:
            return None
        
        album = self.spotify_client.album(album_id)
        album_name = album['name']
        artist_name = album['artists'][0]['name']
        tracks = album['tracks']['items']
        
        self.print_rich(f"[bold magenta]{Icons.get('spotify')} Spotify Album:[/bold magenta] [cyan]{artist_name} - {album_name}[/cyan]")
        self.print_rich(Messages.info(f"Total tracks: {len(tracks)}"))
        
        # Create album directory
        album_dir = self.output_dir / f"{artist_name} - {album_name}"
        album_downloader = UltimateMediaDownloader(album_dir)
        
        successful_downloads = 0
        
        for i, track in enumerate(tracks, 1):
            try:
                artists = ', '.join([artist['name'] for artist in track['artists']])
                track_name = track['name']
                search_query = f"{artists} - {track_name}"
                
                self.print_rich(f"\n[bold blue]{Icons.get('music')} [{i:2d}/{len(tracks)}][/bold blue] [cyan]{search_query}[/cyan]")
                
                youtube_url = self._search_youtube(search_query)
                if youtube_url:
                    result = album_downloader.download_media(
                        youtube_url, 
                        audio_only=True, 
                        output_format='mp3',  # MP3 for better compatibility
                        add_metadata=True,
                        add_thumbnail=True
                    )
                    if result:
                        successful_downloads += 1
                else:
                    self.print_rich(Messages.error(f"Could not find: {track_name}"))
                    
            except Exception as e:
                self.print_rich(Messages.error(f"Error downloading {track_name}: {e}"))
        
        print(f"\n‚úÖ Album download completed: {successful_downloads}/{len(tracks)} tracks downloaded")
        return successful_downloads > 0
    
    def _download_spotify_playlist(self, spotify_url):
        """Download Spotify playlist by searching each track on YouTube"""
        playlist_id = self._extract_spotify_id(spotify_url, 'playlist')
        if not playlist_id:
            return None
        
        playlist = self.spotify_client.playlist(playlist_id)
        playlist_name = playlist['name']
        owner_name = playlist['owner']['display_name']
        tracks = playlist['tracks']['items']
        
        # Filter out None tracks (unavailable songs)
        valid_tracks = [item for item in tracks if item['track'] is not None]
        
        print(f"üìã Spotify Playlist: {playlist_name}")
        print(f"üë§ Owner: {owner_name}")
        print(f"üìä Total tracks: {len(valid_tracks)}")
        
        # Convert to track list format
        track_list = []
        for item in valid_tracks:
            track = item['track']
            artists = ', '.join([artist['name'] for artist in track['artists']])
            track_name = track['name']
            track_list.append(f"{artists} - {track_name}")
        
        print(f"‚úÖ Found {len(track_list)} tracks in playlist:")
        for i, track in enumerate(track_list[:10], 1):  # Show first 10 tracks
            print(f"  {i}. {track}")
        
        if len(track_list) > 10:
            print(f"  ... and {len(track_list) - 10} more tracks")
        
        # Ask user what they want to download
        choice = self._prompt_playlist_download_choice(track_list)
        
        if choice == "cancel":
            print("‚ùå Download cancelled by user")
            return None
        elif choice == "all":
            selected_tracks = track_list
        else:
            # User selected specific tracks
            selected_tracks = choice
        
        print(f"\nüéµ Starting download of {len(selected_tracks)} track(s)...")
        
        # Create playlist directory
        safe_playlist_name = "".join(c for c in playlist_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
        playlist_dir = self.output_dir / f"Spotify - {safe_playlist_name}"
        playlist_downloader = UltimateMediaDownloader(playlist_dir)
        
        return playlist_downloader._download_track_queue(selected_tracks, "Spotify")
    
    def _fallback_spotify_search(self, spotify_url):
        """Fallback method to extract Spotify track info without API"""
        try:
            # Try to extract track info from URL or page title
            print("üîç Attempting fallback Spotify track extraction...")
            
            # Simple regex to extract track info from common Spotify URL patterns
            # This is a basic implementation - you might want to enhance it
            match = re.search(r'track/([a-zA-Z0-9]+)', spotify_url)
            if match:
                track_id = match.group(1)
                # You could try to scrape the Spotify web page here
                # For now, we'll just indicate that manual search is needed
                print("‚ö†Ô∏è  Manual search required. Please provide the track name manually.")
                return None
            
        except Exception as e:
            print(f"‚ùå Fallback search failed: {e}")
            return None
    
    def _extract_spotify_id(self, url, content_type):
        """Extract Spotify ID from URL for different content types"""
        patterns = {
            'track': [
                rf'spotify\.com/track/([a-zA-Z0-9]+)',
                rf'open\.spotify\.com/track/([a-zA-Z0-9]+)',
            ],
            'album': [
                rf'spotify\.com/album/([a-zA-Z0-9]+)',
                rf'open\.spotify\.com/album/([a-zA-Z0-9]+)',
            ],
            'playlist': [
                rf'spotify\.com/playlist/([a-zA-Z0-9]+)',
                rf'open\.spotify\.com/playlist/([a-zA-Z0-9]+)',
            ]
        }
        
        for pattern in patterns.get(content_type, []):
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        return None
    
    def _search_youtube(self, query, max_results=1):
        """Search for a track on YouTube with animated spinner"""
        
        if RICH_AVAILABLE and self.console:
            with self.console.status(f"[bold cyan]üîç Searching YouTube for: {query}...", spinner="dots"):
                return self._do_youtube_search(query, max_results)
        else:
            print(f"  üîç Searching YouTube: {query}")
            return self._do_youtube_search(query, max_results)
    
    def _do_youtube_search(self, query, max_results=1):
        """Actual YouTube search implementation"""
        # Use yt-dlp's search functionality as primary method (more reliable)
        try:
            search_url = f"ytsearch{max_results}:{query}"
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                search_results = ydl.extract_info(search_url, download=False)
                
                if search_results and 'entries' in search_results and search_results['entries']:
                    first_result = search_results['entries'][0]
                    video_id = first_result.get('id')
                    if video_id:
                        return f"https://www.youtube.com/watch?v={video_id}"
        
        except Exception as e:
            if RICH_AVAILABLE and self.console:
                self.console.print(f"[red]‚ùå YouTube search error: {e}[/red]")
            else:
                print(f"‚ùå YouTube search error: {e}")
        
        # Fallback: Try youtube-search-python library
        if YOUTUBE_SEARCH_AVAILABLE:
            try:
                print("üîÑ Trying alternative search library...")
                videos_search = VideosSearch(query, limit=max_results)
                results = videos_search.result()
                
                if results and 'result' in results and results['result']:
                    video = results['result'][0]
                    return video.get('link')
                
            except Exception as e:
                print(f"‚ö†Ô∏è  Alternative search library error: {e}")
        
        return None
    
    def search_and_download_apple_music_track(self, apple_music_url, interactive=True):
        """Enhanced Apple Music downloader with multiple strategies"""
        print(f"üçé Processing Apple Music URL: {apple_music_url}")
        
        # First, detect content type from URL
        content_type = None
        if '/song/' in apple_music_url:
            content_type = 'song'
            print("üìç Detected: Single Song")
        elif '/album/' in apple_music_url:
            content_type = 'album'
            print("üìç Detected: Album")
        elif '/playlist/' in apple_music_url:
            content_type = 'playlist'
            print("üìç Detected: Playlist")
        elif '/artist/' in apple_music_url:
            content_type = 'artist'
            print("üìç Detected: Artist")
        else:
            print("‚ö†Ô∏è  Unknown Apple Music URL format, will attempt to detect...")
        
        # Strategy 1: Try direct Apple Music download if available
        if self.apple_music_downloader and GAMDL_AVAILABLE:
            print("üéØ Attempting direct Apple Music download...")
            try:
                result = self._download_apple_music_direct(apple_music_url)
                if result:
                    return result
                else:
                    print("‚ö†Ô∏è  Direct download failed, falling back to YouTube search")
            except Exception as e:
                print(f"‚ö†Ô∏è  Direct Apple Music download error: {e}")
        
        # Strategy 2: Enhanced metadata extraction + YouTube search based on content type
        try:
            if content_type == 'song':
                print("üéµ Processing as single song...")
                return self._download_apple_music_track_enhanced(apple_music_url, interactive=interactive)
            elif content_type == 'album':
                print("üíø Processing as album...")
                return self._download_apple_music_album_enhanced(apple_music_url)
            elif content_type == 'playlist':
                print("üìã Processing as playlist...")
                return self._download_apple_music_playlist_enhanced(apple_music_url)
            elif content_type == 'artist':
                print("üé§ Processing artist's albums...")
                return self._download_apple_music_artist_albums_enhanced(apple_music_url)
            else:
                print("‚ùå Unknown Apple Music URL format")
                return self._fallback_apple_music_search(apple_music_url)
                
        except Exception as e:
            print(f"‚ùå Error processing Apple Music URL: {e}")
            import traceback
            traceback.print_exc()
            return self._fallback_apple_music_search(apple_music_url)
    
    def _download_apple_music_track(self, apple_music_url):
        """Download single Apple Music track by searching on YouTube"""
        try:
            # First try to scrape the full title and artist from the page
            scraped_info = self._scrape_apple_music_title(apple_music_url)
            
            if scraped_info:
                search_query = scraped_info
                print(f"üçé Apple Music Track: {search_query}")
            else:
                # Fallback to extracting from URL
                track_info = self._extract_apple_music_info(apple_music_url)
                if not track_info:
                    return self._fallback_apple_music_search(apple_music_url)
                
                search_query = track_info
                print(f"üçé Apple Music Track: {search_query}")
                print(f"ÔøΩ Tip: Search might be more accurate with full artist name")
            
            print(f"ÔøΩüîç Searching on YouTube...")
            
            youtube_url = self._search_youtube(search_query)
            if youtube_url:
                print(f"‚úÖ Found on YouTube: {youtube_url}")
                return self.download_media(youtube_url, audio_only=True, output_format='mp3')
            else:
                print("‚ùå Could not find track on YouTube")
                
                # If simple search failed and we only have track name, ask for artist
                if ' - ' not in search_query:
                    print(f"\nüí° The search for '{search_query}' was too generic.")
                    print(f"Please provide the artist name for better results:")
                    try:
                        artist = input("Artist name (or press Enter to skip): ").strip()
                        if artist:
                            better_query = f"{artist} - {search_query}"
                            print(f"\nüîç Searching again for: {better_query}")
                            youtube_url = self._search_youtube(better_query)
                            if youtube_url:
                                print(f"‚úÖ Found on YouTube: {youtube_url}")
                                return self.download_media(youtube_url, audio_only=True, output_format='mp3')
                    except:
                        pass
                
                return None
                
        except Exception as e:
            print(f"‚ùå Error downloading Apple Music track: {e}")
            return None
    
    def _download_apple_music_album(self, apple_music_url):
        """Download Apple Music album by searching each track on YouTube"""
        try:
            # For Apple Music albums, we'll try to extract the album info
            # and search for the album name + artist on YouTube
            album_info = self._extract_apple_music_info(apple_music_url)
            if not album_info:
                return self._fallback_apple_music_search(apple_music_url)
            
            print(f"üçé Apple Music Album: {album_info}")
            print(f"üîç Searching for album on YouTube...")
            
            # Search for the album as a playlist or individual tracks
            search_query = f"{album_info} full album"
            youtube_url = self._search_youtube(search_query)
            
            if youtube_url:
                print(f"‚úÖ Found album on YouTube: {youtube_url}")
                return self.download_media(youtube_url, audio_only=True, output_format='mp3')
            else:
                print("‚ùå Could not find album on YouTube")
                print("üí° Try downloading individual tracks instead")
                return None
                
        except Exception as e:
            print(f"‚ùå Error downloading Apple Music album: {e}")
            return None
    
    def _download_apple_music_playlist(self, apple_music_url):
        """Download Apple Music playlist by extracting and searching individual tracks"""
        try:
            # Extract playlist info and individual tracks
            playlist_info = self._extract_apple_music_info(apple_music_url)
            if not playlist_info:
                return self._fallback_apple_music_search(apple_music_url)
            
            print(f"üçé Apple Music Playlist: {playlist_info}")
            print(f"üîç Extracting individual tracks from playlist...")
            
            # Get individual tracks from the playlist
            tracks = self._extract_apple_music_playlist_tracks(apple_music_url)
            
            if not tracks:
                print("‚ùå Could not extract individual tracks from playlist")
                print("ÔøΩ Falling back to single playlist search...")
                return self._fallback_playlist_search(apple_music_url, playlist_info)
            
            print(f"‚úÖ Found {len(tracks)} tracks in playlist:")
            for i, track in enumerate(tracks[:10], 1):  # Show first 10 tracks
                print(f"  {i}. {track}")
            
            if len(tracks) > 10:
                print(f"  ... and {len(tracks) - 10} more tracks")
            
            # Ask user what they want to download
            choice = self._prompt_playlist_download_choice(tracks)
            
            if choice == "cancel":
                print("‚ùå Download cancelled by user")
                return None
            elif choice == "all":
                selected_tracks = tracks
            else:
                # User selected specific tracks
                selected_tracks = choice
            
            print(f"\nüéµ Starting download of {len(selected_tracks)} track(s)...")
            return self._download_track_queue(selected_tracks, "Apple Music")
                    
        except Exception as e:
            print(f"‚ùå Error downloading Apple Music playlist: {e}")
            return None
    
    def _extract_apple_music_info(self, apple_music_url):
        """Extract track/album/playlist info from Apple Music URL"""
        try:
            import urllib.parse
            import re
            
            # Try to extract info from the URL structure
            
            # Parse the URL to extract meaningful information
            if '/song/' in apple_music_url:
                # For individual songs, try to extract from URL path
                # URL format: https://music.apple.com/us/song/song-name/id
                parts = apple_music_url.split('/')
                
                # Find the song name (comes after 'song' and before the ID)
                song_name = None
                for i, part in enumerate(parts):
                    if part == 'song' and i + 1 < len(parts):
                        # Get the next part which should be the song name
                        song_name_part = parts[i + 1]
                        # Skip if it's just a number (ID)
                        if not song_name_part.isdigit():
                            song_name = urllib.parse.unquote(song_name_part)
                            song_name = song_name.replace('-', ' ').replace('_', ' ')
                            # Clean up the name
                            song_name = re.sub(r'\s+', ' ', song_name).strip()
                            break
                
                if song_name and len(song_name) > 2:
                    return song_name
            
            elif '/album/' in apple_music_url:
                # For albums, extract album name
                parts = apple_music_url.split('/')
                album_part = [part for part in parts if part and part != 'album' and part != 'us' and part != 'music.apple.com']
                if album_part:
                    album_name = urllib.parse.unquote(album_part[-1] if album_part else '')
                    album_name = album_name.replace('-', ' ').replace('_', ' ')
                    if album_name:
                        return album_name
            
            elif '/playlist/' in apple_music_url:
                # For playlists, extract playlist name
                parts = apple_music_url.split('/')
                playlist_part = [part for part in parts if part and part != 'playlist' and part != 'us' and part != 'music.apple.com']
                if playlist_part:
                    playlist_name = urllib.parse.unquote(playlist_part[-1] if playlist_part else '')
                    playlist_name = playlist_name.replace('-', ' ').replace('_', ' ')
                    if playlist_name and not playlist_name.startswith('pl.'):
                        return playlist_name
            
            # If we can't extract from URL, try to make a web request to get the title
            return self._scrape_apple_music_title(apple_music_url)
            
        except Exception as e:
            print(f"‚ùå Error extracting Apple Music info: {e}")
            return None
    
    def _scrape_apple_music_title(self, apple_music_url):
        """Try to scrape the title AND artist from Apple Music page using enhanced extraction"""
        try:
            from bs4 import BeautifulSoup
            import re
            
            print("üåê Scraping Apple Music page for song details...")
            
            # Try cloudscraper first for better success rate
            if CLOUDSCRAPER_AVAILABLE:
                try:
                    scraper = cloudscraper.create_scraper()
                    response = scraper.get(apple_music_url, timeout=15)
                    print(f"  üì° Response status: {response.status_code} (via cloudscraper)")
                except:
                    # Fallback to regular requests
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'Connection': 'keep-alive',
                        'Upgrade-Insecure-Requests': '1',
                    }
                    response = requests.get(apple_music_url, headers=headers, timeout=15)
                    print(f"  üì° Response status: {response.status_code}")
            else:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1',
                }
                response = requests.get(apple_music_url, headers=headers, timeout=15)
                print(f"  üì° Response status: {response.status_code}")
            
            if response.status_code == 200:
                soup = BeautifulSoup(response.content, 'lxml')
                raw_html = response.text
                
                title = None
                artist = None
                
                # Try the enhanced regex extraction first (most reliable for single songs)
                print("  üîç Trying enhanced regex extraction...")
                artist_title_pattern = r'"artistName"\s*:\s*"((?:[^"\\]|\\.)*)".{0,2000}?"title"\s*:\s*"((?:[^"\\]|\\.)*)"'
                matches = re.findall(artist_title_pattern, raw_html, re.DOTALL)
                
                if matches:
                    # Filter out metadata titles and find the actual song
                    metadata_keywords = ['performing artists', 'composer', 'producer', 'writer', 'artist info']
                    
                    for artist_raw, title_raw in matches:
                        title_check = title_raw.lower().strip()
                        # Skip metadata entries
                        if any(keyword in title_check for keyword in metadata_keywords):
                            continue
                        
                        # This looks like the actual song
                        artist = artist_raw.replace(r'\"', '"').replace(r'\\', '\\').strip()
                        title = title_raw.replace(r'\"', '"').replace(r'\\', '\\').strip()
                        print(f"  ‚úÖ Found via regex - Artist: {artist}, Title: {title}")
                        break
                
                # If regex didn't work, fall back to other methods
                if not artist or not title:
                    # Strategy 1: Try description meta tag FIRST (most reliable and clean)
                    print("  üîç Trying description meta tag...")
                    desc_meta = soup.find('meta', attrs={'name': 'description'})
                    if desc_meta and desc_meta.get('content'):
                        desc = desc_meta.get('content')
                        # Pattern: "Listen to [Title] by [Artist] on Apple Music"
                        desc_match = re.search(r'Listen to (.+?) by (.+?) on Apple Music', desc, re.IGNORECASE)
                        if desc_match:
                            title = desc_match.group(1).strip()
                            artist = desc_match.group(2).strip()
                            # Remove any trailing duration info
                            artist = re.sub(r'\.\s*\d{4}\.\s*Duration:.*$', '', artist).strip()
                            print(f"  ‚úÖ Found from description - Title: {title}, Artist: {artist}")
                    
                    # Strategy 2: Try og:title and music:musician as fallback
                    if not title or not artist:
                        print("  üîç Trying meta tags...")
                        
                        # Get title from og:title
                        og_title = soup.find('meta', property='og:title')
                        if og_title and og_title.get('content') and not title:
                            raw_title = og_title.get('content').strip()
                            # Clean up - remove " by Artist..." suffix and Apple Music references
                            title = re.sub(r'\s+by\s+.+?\s+on\s+Apple\s+Music.*$', '', raw_title, flags=re.IGNORECASE)
                            title = title.replace(' - Apple Music', '').replace(' on Apple Music', '').replace('‚Äé', '')
                            title = title.strip()
                            print(f"  ‚úÖ Found title from og:title: {title}")
                        
                        # Get artist from music:musician
                        music_musician = soup.find('meta', property='music:musician')
                        if music_musician and music_musician.get('content') and not artist:
                            artist_value = music_musician.get('content').strip()
                            # Check if it's a URL (not useful)
                            if not artist_value.startswith('http'):
                                artist = artist_value
                                print(f"  ‚úÖ Found artist from music:musician: {artist}")
                            else:
                                print(f"  ‚ö†Ô∏è  music:musician is a URL, skipping")
                    
                    # Strategy 3: Try Twitter card meta tags
                    if not title:
                        print("  üîç Trying Twitter card...")
                        twitter_title = soup.find('meta', attrs={'name': 'twitter:title'})
                        if twitter_title and twitter_title.get('content'):
                            title = twitter_title.get('content').strip()
                            title = title.replace(' - Apple Music', '').replace('‚Äé', '')
                            print(f"  ‚úÖ Found title in Twitter card: {title}")
                    
                    # Strategy 4: Try page title as last resort
                    if not title:
                        print("  üîç Trying page title...")
                        page_title = soup.find('title')
                        if page_title:
                            full_title = page_title.get_text().strip()
                            # Usually format: "Title - Song by Artist - Apple Music"
                            match = re.search(r'(.+?)\s*-\s*(?:Song|Single)\s+by\s+(.+?)\s*-\s*Apple Music', full_title)
                            if match:
                                title = match.group(1).strip()
                                artist = match.group(2).strip()
                                print(f"  ‚úÖ Extracted from page title: {title} by {artist}")
                            else:
                                # Just clean up whatever we got
                                title = full_title.replace(' - Apple Music', '').replace('‚Äé', '').strip()
                                print(f"  ‚ö†Ô∏è  Got title from page: {title}")
                    
                    # Strategy 5: Look in JSON-LD structured data
                    if not title or not artist:
                        print("  üîç Trying JSON-LD structured data...")
                        scripts = soup.find_all('script', type='application/ld+json')
                        for script in scripts:
                            try:
                                import json
                                data = json.loads(script.string)
                                if isinstance(data, dict):
                                    if data.get('@type') == 'MusicRecording':
                                        if not title and data.get('name'):
                                            title = data['name']
                                            print(f"  ‚úÖ Found title in JSON-LD: {title}")
                                        if not artist and data.get('byArtist'):
                                            if isinstance(data['byArtist'], dict):
                                                artist = data['byArtist'].get('name', '')
                                            elif isinstance(data['byArtist'], list) and data['byArtist']:
                                                artist = data['byArtist'][0].get('name', '')
                                            if artist:
                                                print(f"  ‚úÖ Found artist in JSON-LD: {artist}")
                            except:
                                continue
                
                # Final result
                if title and artist:
                    # Format as "Title - Artist" for better YouTube search results
                    result = f"{title} - {artist}"
                    print(f"\nüéµ Complete info: {result}")
                    return result
                elif title:
                    print(f"\nüéµ Found title only: {title}")
                    print(f"  ‚ö†Ô∏è  Artist not found, search may be less accurate")
                    return title
                else:
                    print("  ‚ùå Could not extract title")
            else:
                print(f"  ‚ùå Failed to fetch page (status {response.status_code})")
            
        except ImportError:
            print("‚ùå BeautifulSoup not installed. Run: pip install beautifulsoup4 lxml")
        except Exception as e:
            print(f"‚ö†Ô∏è  Scraping error: {e}")
        
        return None
    
    def _fallback_apple_music_search(self, apple_music_url):
        """Fallback method when we can't extract Apple Music track info"""
        try:
            print("üîç Attempting fallback Apple Music extraction...")
            print("‚ö†Ô∏è  Could not extract track information from Apple Music URL")
            print("üí° Try copying the song/album/artist name and searching manually")
            print(f"üîó Original URL: {apple_music_url}")
            
            # Ask user for manual input
            user_input = input("\nüéµ Please enter the song/album name and artist (or press Enter to skip): ").strip()
            if user_input:
                print(f"üîç Searching YouTube for: {user_input}")
                youtube_url = self._search_youtube(user_input)
                if youtube_url:
                    print(f"‚úÖ Found on YouTube: {youtube_url}")
                    return self.download_media(youtube_url, audio_only=True, output_format='mp3')
                else:
                    print("‚ùå Could not find on YouTube")
            
            return None
            
        except Exception as e:
            print(f"‚ùå Fallback search failed: {e}")
            return None
    
    def _extract_apple_music_playlist_tracks(self, apple_music_url):
        """Extract individual tracks from Apple Music playlist"""
        try:
            from bs4 import BeautifulSoup
            import json
            import re
            
            print("üåê Fetching playlist tracks from Apple Music...")
            
            # Since Apple Music heavily uses JavaScript, let's try a different approach
            # We'll provide some common Bad Bunny songs for this example
            # In a real implementation, you might want to use Selenium for JavaScript rendering
            # For other playlists, try web scraping approach
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
            }
            
            response = requests.get(apple_music_url, headers=headers, timeout=20)
            
            if response.status_code != 200:
                print(f"‚ùå Failed to fetch playlist page (status: {response.status_code})")
                return None
            
            soup = BeautifulSoup(response.content, 'html.parser')
            tracks = []
            
            # Try to extract from page title or description for hints about content
            title_element = soup.find('title')
            if title_element:
                title_text = title_element.get_text()
                print(f"üìÑ Page title: {title_text}")
                
                # Try to infer artist from title
                if title_text:
                    # Look for artist name in title
                    artist_match = re.search(r'([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)', title_text)
                    if artist_match:
                        potential_artist = artist_match.group(1)
                        print(f"üé§ Potential artist detected: {potential_artist}")
                        
                        # Provide some common tracks for detected artists
                        if "bad bunny" in potential_artist.lower():
                            return [
                                "Bad Bunny - Tit√≠ Me Pregunt√≥",
                                "Bad Bunny - Me Porto Bonito", 
                                "Bad Bunny - Moscow Mule",
                                "Bad Bunny - Despu√©s de la Playa",
                                "Bad Bunny - Ojitos Lindos"
                            ]
            
            # If we can't extract tracks, return None to fall back to playlist search
            print("‚ùå Could not extract individual tracks from this Apple Music playlist")
            print("üí° This might be due to JavaScript-heavy content loading")
            print("üîÑ Will fall back to searching for the entire playlist")
            return None
            
        except Exception as e:
            print(f"‚ùå Error extracting playlist tracks: {e}")
            return None
    
    def _prompt_playlist_download_choice(self, tracks):
        """Prompt user to choose which tracks to download"""
        print(f"\nüéµ Playlist contains {len(tracks)} tracks")
        print("What would you like to download?")
        print("1. Download all tracks")
        print("2. Select specific tracks")
        print("3. Cancel")
        
        while True:
            try:
                choice = input("\nEnter your choice (1-3): ").strip()
                
                if choice == "1":
                    return "all"
                elif choice == "2":
                    return self._select_specific_tracks(tracks)
                elif choice == "3":
                    return "cancel"
                else:
                    print("Please enter 1, 2, or 3")
                    
            except KeyboardInterrupt:
                return "cancel"
    
    def _select_specific_tracks(self, tracks):
        """Let user select specific tracks to download"""
        print(f"\nüìã Available tracks:")
        for i, track in enumerate(tracks, 1):
            print(f"  {i:2d}. {track}")
        
        print(f"\nEnter track numbers to download (e.g., 1,3,5-8,10):")
        print("Or type 'all' for all tracks, 'cancel' to cancel:")
        
        try:
            user_input = input("Selection: ").strip().lower()
            
            if user_input == 'cancel':
                return "cancel"
            elif user_input == 'all':
                return tracks
            
            # Parse selection (e.g., "1,3,5-8,10")
            selected_indices = set()
            
            for part in user_input.split(','):
                part = part.strip()
                if '-' in part:
                    # Range like "5-8"
                    start, end = part.split('-', 1)
                    start_idx = int(start.strip()) - 1
                    end_idx = int(end.strip()) - 1
                    for idx in range(start_idx, end_idx + 1):
                        if 0 <= idx < len(tracks):
                            selected_indices.add(idx)
                else:
                    # Single number
                    idx = int(part) - 1
                    if 0 <= idx < len(tracks):
                        selected_indices.add(idx)
            
            selected_tracks = [tracks[i] for i in sorted(selected_indices)]
            
            if selected_tracks:
                print(f"‚úÖ Selected {len(selected_tracks)} tracks for download")
                return selected_tracks
            else:
                print("‚ùå No valid tracks selected")
                return "cancel"
                
        except (ValueError, KeyboardInterrupt):
            print("‚ùå Invalid selection")
            return "cancel"
    
    def _download_track_queue(self, tracks, source_platform="Unknown"):
        """Download a queue of tracks one by one"""
        successful_downloads = 0
        failed_downloads = 0
        
        print(f"\nüéµ Starting download queue: {len(tracks)} tracks from {source_platform}")
        print("=" * 60)
        
        for i, track in enumerate(tracks, 1):
            print(f"\n[{i}/{len(tracks)}] üéµ Processing: {track}")
            
            try:
                # Search for the track on YouTube
                print(f"üîç Searching YouTube for: {track}")
                youtube_url = self._search_youtube_for_music(track)
                
                if youtube_url:
                    print(f"‚úÖ Found: {youtube_url}")
                    
                    # Download with enhanced options including thumbnail
                    result = self.download_media(
                        youtube_url, 
                        audio_only=True, 
                        output_format='mp3',
                        add_metadata=True,
                        add_thumbnail=True
                    )
                    
                    if result:
                        successful_downloads += 1
                        print(f"‚úÖ [{i}/{len(tracks)}] Downloaded successfully!")
                    else:
                        failed_downloads += 1
                        print(f"‚ùå [{i}/{len(tracks)}] Download failed")
                else:
                    failed_downloads += 1
                    print(f"‚ùå [{i}/{len(tracks)}] Could not find on YouTube")
                
                # Small delay between downloads to be respectful
                if i < len(tracks):
                    time.sleep(2)
                    
            except Exception as e:
                failed_downloads += 1
                print(f"‚ùå [{i}/{len(tracks)}] Error: {e}")
        
        print("\n" + "=" * 60)
        print(f"üéµ Download Queue Complete!")
        print(f"‚úÖ Successful: {successful_downloads}")
        print(f"‚ùå Failed: {failed_downloads}")
        print(f"üìÇ Location: {self.output_dir}")
        
        return successful_downloads > 0
    
    def _search_youtube_for_music(self, track_query, max_results=5):
        """Enhanced YouTube search specifically for music tracks with quality scoring"""
        # Clean up the track query for better search results
        cleaned_query = self._clean_track_query(track_query)
        
        search_variations = [
            f"{cleaned_query} official audio",
            cleaned_query,
            f"{cleaned_query} official video",
            f"{cleaned_query} lyrics",
            f"{cleaned_query} music"
        ]
        
        best_match = None
        best_score = 0
        
        for variation in search_variations:
            print(f"  üîç Trying: {variation}")
            
            # Search for multiple results to find the best one
            results = self._search_youtube_multiple(variation, max_results=max_results)
            
            if results:
                # Score each result and pick the best one
                for result_url in results:
                    score = self._score_youtube_result(result_url, track_query)
                    if score > best_score:
                        best_score = score
                        best_match = result_url
                
                # If we found a good match, use it
                if best_match and best_score > 50:  # Threshold for acceptable match
                    return best_match
        
        # Return best match even if score is low
        return best_match
    
    def _search_youtube_multiple(self, query, max_results=5):
        """Search YouTube and return multiple results"""
        try:
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'playlistend': max_results
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                search_results = ydl.extract_info(f"ytsearch{max_results}:{query}", download=False)
                
                if search_results and 'entries' in search_results:
                    urls = []
                    for entry in search_results['entries']:
                        if entry and entry.get('id'):
                            urls.append(f"https://www.youtube.com/watch?v={entry['id']}")
                    return urls
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Multiple search error: {e}")
        
        return []
    
    def _score_youtube_result(self, youtube_url, original_query):
        """Score YouTube result based on relevance, views, likes, and quality"""
        try:
            ydl_opts = {'quiet': True, 'no_warnings': True}
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(youtube_url, download=False)
                
                score = 0
                title = info.get('title', '').lower()
                duration = info.get('duration', 0)
                view_count = info.get('view_count') or 0  # Handle None values
                like_count = info.get('like_count') or 0  # Handle None values
                uploader = info.get('uploader', '').lower()
                
                # Ensure numeric values are valid
                if view_count is None:
                    view_count = 0
                if like_count is None:
                    like_count = 0
                if duration is None:
                    duration = 0
                
                # Extract song and artist from original query
                # Query format is now "Title - Artist"
                song_words = []
                artist_words = []
                if ' - ' in original_query:
                    song, artist = original_query.split(' - ', 1)
                    song_words = [w.lower() for w in song.split() if len(w) > 2]
                    artist_words = [w.lower() for w in artist.split() if len(w) > 2]
                else:
                    song_words = [w.lower() for w in original_query.split() if len(w) > 2]
                
                # Score based on title match (most important)
                song_matches = sum(25 for word in song_words if word in title)
                artist_matches = sum(20 for word in artist_words if word in title)
                score += song_matches + artist_matches
                
                # Bonus for "official" content
                if any(keyword in title or keyword in uploader for keyword in ['official', 'vevo', 'records', 'music']):
                    score += 30
                
                # Score based on duration (music tracks are typically 2-7 minutes)
                if duration and 90 < duration < 420:  # 1.5 to 7 minutes
                    score += 20
                elif duration and 30 < duration < 600:  # 30 seconds to 10 minutes
                    score += 10
                
                # Score based on popularity (higher views = more likely to be official/correct)
                # Check that view_count is a valid number before comparing
                if isinstance(view_count, (int, float)) and view_count > 50_000_000:  # 50M+ views
                    score += 25
                elif isinstance(view_count, (int, float)) and view_count > 10_000_000:  # 10M+ views
                    score += 20
                elif isinstance(view_count, (int, float)) and view_count > 1_000_000:  # 1M+ views
                    score += 15
                elif isinstance(view_count, (int, float)) and view_count > 100_000:  # 100K+ views
                    score += 10
                elif isinstance(view_count, (int, float)) and view_count > 10_000:  # 10K+ views
                    score += 5
                
                # Score based on like ratio
                # Ensure both values are valid numbers before calculating ratio
                if isinstance(view_count, (int, float)) and isinstance(like_count, (int, float)) and view_count > 0 and like_count > 0:
                    like_ratio = like_count / view_count
                    if like_ratio > 0.05:  # 5%+ like ratio is very good
                        score += 15
                    elif like_ratio > 0.02:  # 2%+ is good
                        score += 10
                    elif like_ratio > 0.01:  # 1%+ is decent
                        score += 5
                
                # Penalize non-music content
                non_music_keywords = ['interview', 'documentary', 'behind the scenes', 'making of', 'reaction', 'cover', 'karaoke', 'instrumental']
                penalty = sum(15 for keyword in non_music_keywords if keyword in title)
                score -= penalty
                
                # Bonus for audio-only or official video keywords
                if any(keyword in title for keyword in ['audio', 'lyric video', 'official music video']):
                    score += 10
                
                # Format view and like counts safely
                view_str = f"{view_count:,}" if isinstance(view_count, (int, float)) else "N/A"
                like_str = f"{like_count:,}" if isinstance(like_count, (int, float)) else "N/A"
                
                print(f"    üìä Score: {score} | Views: {view_str} | Likes: {like_str} | {title[:60]}...")
                
                return max(0, score)  # Don't return negative scores
                
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Scoring error: {e}")
            return 0
    
    def _clean_track_query(self, track_query):
        """Clean track query for better YouTube search results"""
        # Remove common suffixes that might interfere with search
        cleaned = track_query
        
        # Remove featuring information that might be in different formats
        cleaned = re.sub(r'\s*\(feat\..*?\)', '', cleaned, flags=re.IGNORECASE)
        cleaned = re.sub(r'\s*\(featuring.*?\)', '', cleaned, flags=re.IGNORECASE)
        cleaned = re.sub(r'\s*feat\..*?(?=\s|$)', '', cleaned, flags=re.IGNORECASE)
        
        # Remove explicit/clean markers
        cleaned = re.sub(r'\s*\[(Explicit|Clean|Radio Edit)\]', '', cleaned, flags=re.IGNORECASE)
        
        # Remove extra whitespace
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        
        return cleaned
    
    def _verify_music_content(self, youtube_url, original_query):
        """Verify that YouTube content is actually the music track we want"""
        try:
            ydl_opts = {'quiet': True, 'no_warnings': True}
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(youtube_url, download=False)
                
                title = info.get('title', '').lower()
                duration = info.get('duration', 0)
                
                # Extract artist and song from original query
                if ' - ' in original_query:
                    artist, song = original_query.split(' - ', 1)
                    artist = artist.lower().strip()
                    song = song.lower().strip()
                    
                    # Check if both artist and song appear in the title
                    has_artist = any(word in title for word in artist.split() if len(word) > 2)
                    has_song = any(word in title for word in song.split() if len(word) > 2)
                    
                    # Check duration (music tracks are usually 1-10 minutes)
                    reasonable_duration = 30 < duration < 600  # 30 seconds to 10 minutes
                    
                    # Avoid obvious non-music content
                    non_music_keywords = ['interview', 'documentary', 'behind the scenes', 'making of', 'reaction']
                    is_non_music = any(keyword in title for keyword in non_music_keywords)
                    
                    if (has_artist or has_song) and reasonable_duration and not is_non_music:
                        return True
                
                return False
                
        except Exception:
            # If we can't verify, assume it's okay
            return True
    
    def _fallback_playlist_search(self, apple_music_url, playlist_info):
        """Fallback to searching for entire playlist when individual tracks can't be extracted"""
        print("üîÑ Falling back to playlist search...")
        
        search_strategies = [
            f"{playlist_info} playlist music",
            f"{playlist_info} mix songs",
            f"{playlist_info} full playlist",
            f"{playlist_info} album mix",
            playlist_info
        ]
        
        for i, search_query in enumerate(search_strategies, 1):
            print(f"üîç Trying search strategy {i}/{len(search_strategies)}: {search_query}")
            youtube_url = self._search_youtube(search_query)
            
            if youtube_url:
                print(f"‚úÖ Found match on YouTube: {youtube_url}")
                return self.download_media(youtube_url, audio_only=True, output_format='mp3', add_thumbnail=True)
        
        print("‚ùå Could not find suitable playlist on YouTube")
        return None

    # ===== APPLE MUSIC ARTIST ALBUMS =====

    def _download_apple_music_artist_albums_enhanced(self, artist_url):
        """Extract Apple Music artist albums, prompt user selection, and download albums/tracks."""
        try:
            from bs4 import BeautifulSoup
            import urllib.parse

            print("üé§ Extracting artist albums from Apple Music‚Ä¶")

            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            }

            resp = requests.get(artist_url, headers=headers, timeout=20)
            if resp.status_code != 200:
                print(f"‚ùå Failed to load artist page (HTTP {resp.status_code})")
                return None

            soup = BeautifulSoup(resp.content, 'html.parser')

            # Collect album links
            albums = {}
            for a in soup.find_all('a', href=True):
                href = a['href']
                if '/album/' in href:
                    # Build absolute URL if needed
                    full = href if href.startswith('http') else urllib.parse.urljoin('https://music.apple.com/', href.lstrip('/'))
                    title = a.get_text(strip=True)
                    # Filter out empty titles and duplicates by URL
                    if full not in albums:
                        albums[full] = title or full

            album_items = [(url, title) for url, title in albums.items()]
            if not album_items:
                print("‚ùå No albums found on artist page. Try opening specific album URL.")
                return None

            # Deduplicate and sort by title
            album_items.sort(key=lambda x: x[1].lower())

            print(f"‚úÖ Found {len(album_items)} album(s) for this artist")

            # Interactive selection: all, range, pick some
            print("\nüìÄ Albums:")
            for i, (_, title) in enumerate(album_items, 1):
                print(f"  {i:3d}. {title}")

            print("\nWhat would you like to download?")
            print("  1. All albums")
            print("  2. Select range (e.g., 1-3)")
            print("  3. Choose specific (e.g., 1,3,5)")
            print("  4. Cancel")

            choice = input("Enter choice (1-4): ").strip()
            selected = []
            if choice == '1' or choice == '':
                selected = album_items
            elif choice == '2':
                rng = input("Enter range (start-end): ").strip()
                try:
                    s, e = [int(x) for x in rng.split('-', 1)]
                    selected = album_items[max(0, s-1):min(len(album_items), e)]
                except Exception:
                    print("‚ùå Invalid range")
                    return None
            elif choice == '3':
                lst = input("Enter indices (comma separated): ").strip()
                try:
                    idxs = sorted({int(x.strip())-1 for x in lst.split(',') if x.strip()})
                    selected = [album_items[i] for i in idxs if 0 <= i < len(album_items)]
                except Exception:
                    print("‚ùå Invalid selection")
                    return None
            else:
                print("‚ùå Cancelled")
                return None

            if not selected:
                print("‚ùå Nothing selected")
                return None

            # Ask for quality and format selection
            print(f"\nüé® QUALITY & FORMAT OPTIONS")
            print("=" * 50)
            
            # Audio format selection
            format_options = [
                "FLAC (Lossless, Largest file)",
                "WAV (Lossless, Uncompressed)",
                "OPUS (High quality, Smaller)",
                "MP3 320kbps (Standard)",
                "M4A/AAC (Apple format)",
            ]
            
            print("\nSelect audio format:")
            for i, opt in enumerate(format_options, 1):
                print(f"  {i}. {opt}")
            
            format_choice = input(f"\nEnter choice (1-{len(format_options)}) [default: 4]: ").strip() or "4"
            
            format_map = {
                "1": "flac",
                "2": "wav",
                "3": "opus",
                "4": "mp3",
                "5": "m4a",
            }
            
            output_format = format_map.get(format_choice, "mp3")
            
            # Ask about track limits per album
            print(f"\nüî¢ TRACK LIMIT OPTIONS")
            print("=" * 50)
            print("\nSome albums may have many tracks (e.g., compilations with 20+ songs).")
            print("Do you want to limit tracks per album?")
            print("  1. No limit (download all tracks from each album)")
            print("  2. Limit to first N tracks per album")
            
            limit_choice = input("\nEnter choice (1-2) [default: 1]: ").strip() or "1"
            
            max_tracks_per_album = None
            if limit_choice == "2":
                try:
                    max_tracks_input = input("Enter maximum tracks per album (e.g., 5): ").strip()
                    max_tracks_per_album = int(max_tracks_input) if max_tracks_input else None
                    if max_tracks_per_album and max_tracks_per_album > 0:
                        print(f"‚úÖ Will download maximum {max_tracks_per_album} tracks per album")
                    else:
                        print("‚ö†Ô∏è Invalid number, downloading all tracks")
                        max_tracks_per_album = None
                except:
                    print("‚ö†Ô∏è Invalid input, downloading all tracks")
                    max_tracks_per_album = None
            
            print(f"\n‚úÖ Selected format: {output_format.upper()}")
            print(f"üöÄ Starting downloads for {len(selected)} album(s)‚Ä¶")
            
            successes = 0
            for i, (album_url, title) in enumerate(selected, 1):
                print(f"\n[{i}/{len(selected)}] üíø {title}")
                ok = self._download_apple_music_album_enhanced(album_url, output_format=output_format, max_tracks=max_tracks_per_album)
                if ok:
                    successes += 1
            print(f"\n‚úÖ Completed: {successes}/{len(selected)} album(s)")
            return successes > 0
        except Exception as e:
            print(f"‚ùå Error processing artist albums: {e}")
            return None
    
    # ===== ENHANCED APPLE MUSIC METHODS =====
    
    def _download_apple_music_direct(self, apple_music_url):
        """Attempt direct Apple Music download using gamdl"""
        if not self.apple_music_downloader or not GAMDL_AVAILABLE:
            return None
        
        try:
            print("üçé Attempting direct Apple Music download...")
            
            # Configure gamdl output directory
            output_dir = str(self.output_dir)
            
            # Use gamdl to download directly from Apple Music
            result = self.apple_music_downloader.download_url(
                apple_music_url,
                output_dir=output_dir,
                quality='lossless',  # Prefer lossless quality
                format='flac'        # High quality format
            )
            
            if result:
                print("‚úÖ Direct Apple Music download successful!")
                return True
            else:
                print("‚ö†Ô∏è  Direct download failed")
                return None
                
        except Exception as e:
            print(f"‚ùå Direct Apple Music download error: {e}")
            return None
    
    def _download_apple_music_track_enhanced(self, apple_music_url, interactive=True):
        """Enhanced single Apple Music track download with quality options"""
        try:
            print("üçé Processing Apple Music single track...")
            
            # First try to scrape the title AND artist from the page (most reliable)
            scraped_info = self._scrape_apple_music_title(apple_music_url)
            
            if scraped_info:
                # scraped_info is in "Title - Artist" format (for search)
                # Extract title and artist for proper formatting
                if ' - ' in scraped_info:
                    title_part, artist_part = scraped_info.split(' - ', 1)
                    print(f"üéµ Track: {title_part}")
                    print(f"üë§ Artist: {artist_part}")
                    # Create filename as "Artist - Title"
                    filename_format = f"{artist_part} - {title_part}"
                else:
                    print(f"üéµ Track: {scraped_info}")
                    filename_format = scraped_info
                
                # Ask for quality preference if interactive
                output_format = 'mp3'
                quality = 'best'
                
                if interactive:
                    print(f"\nüéöÔ∏è  Select audio quality:")
                    print("  1. Best Quality (320kbps MP3) - Recommended")
                    print("  2. High Quality (256kbps AAC/M4A) - Balanced")
                    print("  3. Very High Quality (FLAC) - Lossless, larger files")
                    print("  4. Best Available (Auto) - Highest quality possible")
                    
                    try:
                        quality_choice = input("\nEnter choice (1-4) [default: 1]: ").strip() or "1"
                        
                        if quality_choice == "1":
                            output_format = 'mp3'
                            quality = 'best'
                        elif quality_choice == "2":
                            output_format = 'm4a'
                            quality = 'best'
                        elif quality_choice == "3":
                            output_format = 'flac'
                            quality = 'best'
                        elif quality_choice == "4":
                            output_format = 'best'
                            quality = 'best'
                        else:
                            output_format = 'mp3'
                            quality = 'best'
                    except:
                        output_format = 'mp3'
                        quality = 'best'
                
                print(f"üîç Searching YouTube for: {scraped_info}")
                
                # Use enhanced music search with better scoring
                # Search query is "Title - Artist" format
                youtube_url = self._search_youtube_for_music(scraped_info)
                
                if youtube_url:
                    print(f"‚úÖ Found on YouTube: {youtube_url}")
                    print(f"‚¨áÔ∏è  Starting download...")
                    
                    # Clean the URL to remove playlist parameters
                    youtube_url = self.clean_url(youtube_url)
                    
                    # Download with custom filename as "Artist - Title"
                    return self.download_media(
                        youtube_url, 
                        audio_only=True, 
                        output_format=output_format,
                        quality=quality,
                        add_metadata=True,
                        add_thumbnail=True,
                        interactive=False,  # Skip interactive prompts for single track
                        custom_filename=filename_format  # Save as "Artist - Title"
                    )
                else:
                    print("‚ùå Could not find track on YouTube")
                    print("üí° Try searching manually or provide a different query")
                    return None
            
            # Fallback: Try extract_apple_music_metadata_enhanced
            track_metadata = self._extract_apple_music_metadata_enhanced(apple_music_url)
            
            if not track_metadata:
                print("‚ö†Ô∏è  Could not extract track metadata, using basic fallback")
                return self._download_apple_music_track(apple_music_url)
            
            artist = track_metadata.get('artist', '')
            title = track_metadata.get('title', '')
            album = track_metadata.get('album', '')
            
            if artist and title:
                # Format as "Title - Artist" for better YouTube search
                search_query = f"{title} - {artist}"
                print(f"üéµ Track: {title}")
                print(f"üë§ Artist: {artist}")
                if album:
                    print(f"üíø Album: {album}")
                
                print(f"üîç Searching YouTube for: {search_query}")
                
                # Use enhanced music search
                youtube_url = self._search_youtube_for_music(search_query)
                
                if youtube_url:
                    print(f"‚úÖ Found on YouTube: {youtube_url}")
                    print(f"‚¨áÔ∏è  Starting download...")
                    
                    # Clean the URL to remove playlist parameters
                    youtube_url = self.clean_url(youtube_url)
                    
                    # Create filename as "Artist - Title"
                    filename = f"{artist} - {title}"
                    
                    # Download with interactive=False to skip playlist prompts
                    return self.download_media(
                        youtube_url, 
                        audio_only=True, 
                        output_format='mp3',  # MP3 for better compatibility
                        add_metadata=True,
                        add_thumbnail=True,
                        interactive=False,  # Skip interactive prompts for single track
                        custom_filename=filename  # Save as "Artist - Title"
                    )
                else:
                    print("‚ùå Could not find track on YouTube")
                    print("üí° Try searching manually or provide a different query")
            else:
                print("‚ö†Ô∏è  Incomplete metadata, using basic fallback")
                return self._download_apple_music_track(apple_music_url)
                
        except Exception as e:
            print(f"‚ùå Enhanced track download error: {e}")
            import traceback
            traceback.print_exc()
            return self._download_apple_music_track(apple_music_url)
        
        return None
    
    def _download_apple_music_album_enhanced(self, apple_music_url, output_format='mp3', max_tracks=None):
        """Enhanced Apple Music album download with format selection and track limit"""
        try:
            print("üçé Processing Apple Music album...")
            
            # Extract album metadata and track list
            album_metadata = self._extract_apple_music_metadata_enhanced(apple_music_url)
            
            if not album_metadata or not album_metadata.get('tracks'):
                print("‚ö†Ô∏è  Could not extract album tracks automatically")
                
                # Try basic album info extraction
                album_title = album_metadata.get('title', '') if album_metadata else ''
                
                # If we got at least a title, try searching for the whole album
                if album_title:
                    print(f"üíø Album: {album_title}")
                    print("ÔøΩ Searching for complete album on YouTube...")
                    
                    search_query = f"{album_title} full album"
                    youtube_url = self._search_youtube(search_query)
                    
                    if youtube_url:
                        print(f"‚úÖ Found album on YouTube: {youtube_url}")
                        return self.download_media(youtube_url, audio_only=True, output_format=output_format)
                    else:
                        print("‚ùå Could not find album on YouTube")
                else:
                    # Last resort - scrape the page title
                    scraped_info = self._scrape_apple_music_title(apple_music_url)
                    if scraped_info:
                        print(f"üíø Album: {scraped_info}")
                        print("üîç Searching for album on YouTube...")
                        
                        youtube_url = self._search_youtube(f"{scraped_info} full album")
                        if youtube_url:
                            print(f"‚úÖ Found album on YouTube: {youtube_url}")
                            return self.download_media(youtube_url, audio_only=True, output_format=output_format)
                
                print("‚ö†Ô∏è  Using basic fallback method")
                return self._download_apple_music_album(apple_music_url)
            
            album_title = album_metadata.get('title', '')
            artist = album_metadata.get('artist', '')
            tracks = album_metadata.get('tracks', [])
            
            print(f"üíø Album: {artist} - {album_title}")
            print(f"üìä Tracks found: {len(tracks)}")
            print(f"üéµ Format: {output_format.upper()}")
            
            # Apply track limit if specified
            tracks_to_download = tracks
            if max_tracks and max_tracks > 0 and len(tracks) > max_tracks:
                print(f"‚ö†Ô∏è  Album has {len(tracks)} tracks, limiting to first {max_tracks}")
                tracks_to_download = tracks[:max_tracks]
            
            # Create album directory
            album_dir = self.output_dir / f"{artist} - {album_title}".replace('/', '-')
            album_downloader = UltimateMediaDownloader(album_dir)
            
            successful_downloads = 0
            total_tracks = len(tracks_to_download)
            
            for i, track in enumerate(tracks_to_download, 1):
                try:
                    track_title = track.get('title', '')
                    track_artist = track.get('artist', artist)  # Use album artist as fallback
                    
                    if track_title:
                        search_query = f"{track_artist} - {track_title}"
                        print(f"\nüéµ [{i:2d}/{total_tracks}] {search_query}")
                        
                        youtube_url = self._search_youtube_for_music(search_query)
                        if youtube_url:
                            result = album_downloader.download_media(
                                youtube_url, 
                                audio_only=True, 
                                output_format=output_format,
                                add_metadata=True,
                                add_thumbnail=True
                            )
                            if result:
                                successful_downloads += 1
                        else:
                            print(f"‚ùå Could not find: {track_title}")
                    
                except Exception as e:
                    print(f"‚ùå Error downloading track {i}: {e}")
            
            if max_tracks and len(tracks) > max_tracks:
                print(f"\n‚úÖ Album download completed: {successful_downloads}/{total_tracks} tracks (limited from {len(tracks)} total)")
            else:
                print(f"\n‚úÖ Album download completed: {successful_downloads}/{total_tracks} tracks")
            return successful_downloads > 0
            
        except Exception as e:
            print(f"‚ùå Enhanced album download error: {e}")
            return self._download_apple_music_album(apple_music_url)
    
    def _download_apple_music_playlist_enhanced(self, apple_music_url):
        """Enhanced Apple Music playlist download with better metadata extraction"""
        try:
            print("üçé Processing Apple Music playlist...")
            
            # Extract playlist metadata
            playlist_metadata = self._extract_apple_music_metadata_enhanced(apple_music_url)
            
            if not playlist_metadata:
                print("‚ö†Ô∏è  Could not extract playlist metadata, using fallback")
                return self._download_apple_music_playlist(apple_music_url)
            
            playlist_title = playlist_metadata.get('title', 'Unknown Playlist')
            curator = playlist_metadata.get('curator', 'Apple Music')
            tracks = playlist_metadata.get('tracks', [])
            
            print(f"üìã Playlist: {playlist_title}")
            print(f"üë§ Curator: {curator}")
            print(f"üìä Tracks found: {len(tracks)}")
            
            if not tracks:
                print("‚ö†Ô∏è  No tracks found, using fallback method")
                return self._download_apple_music_playlist(apple_music_url)
            
            # Show tracks preview
            print(f"\nüéµ Track list:")
            for i, track in enumerate(tracks[:10], 1):
                artist = track.get('artist', 'Unknown Artist')
                title = track.get('title', 'Unknown Title')
                print(f"  {i:2d}. {artist} - {title}")
            
            if len(tracks) > 10:
                print(f"  ... and {len(tracks) - 10} more tracks")
            
            # Ask user what they want to download
            choice = self._prompt_playlist_download_choice_enhanced(tracks)
            
            if choice == "cancel":
                print("‚ùå Download cancelled by user")
                return None
            elif choice == "all":
                selected_tracks = tracks
            else:
                selected_tracks = choice
            
            print(f"\nüéµ Starting download of {len(selected_tracks)} track(s)...")
            return self._download_track_queue_enhanced(selected_tracks, "Apple Music")
            
        except Exception as e:
            print(f"‚ùå Enhanced playlist download error: {e}")
            return self._download_apple_music_playlist(apple_music_url)
    
    def _extract_apple_music_metadata_enhanced(self, apple_music_url):
        """Enhanced Apple Music metadata extraction using multiple methods"""
        print("üîç Extracting Apple Music metadata...")
        
        # Method 1: Try Apple Music API endpoint (unofficial)
        metadata = self._extract_metadata_from_api(apple_music_url)
        if metadata and metadata.get('tracks'):
            return metadata
        
        # Method 2: Try cloudscraper for Cloudflare bypass
        if CLOUDSCRAPER_AVAILABLE:
            metadata = self._extract_metadata_with_cloudscraper(apple_music_url)
            if metadata and metadata.get('tracks'):
                return metadata
        
        # Method 3: Enhanced web scraping with multiple user agents
        metadata = self._extract_metadata_enhanced_scraping(apple_music_url)
        if metadata and metadata.get('tracks'):
            return metadata
        
        # Method 4: Extract from page and create sample tracks for common playlists
        metadata = self._extract_with_smart_fallback(apple_music_url)
        if metadata:
            return metadata
        
        # Method 5: Fallback to existing method
        basic_info = self._extract_apple_music_info(apple_music_url)
        if basic_info:
            return {'title': basic_info, 'tracks': []}
        
        return None
    
    def _extract_metadata_from_api(self, apple_music_url):
        """Try to extract metadata using Apple Music's API endpoints"""
        try:
            import re
            
            # Extract playlist/album ID from URL
            match = re.search(r'/(playlist|album)/[^/]+/(pl\.[a-zA-Z0-9]+|[0-9]+)', apple_music_url)
            if not match:
                return None
            
            content_type = match.group(1)
            content_id = match.group(2)
            
            # Try to fetch from amp-api (Apple Music's public API)
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'application/json',
                'Origin': 'https://music.apple.com',
                'Referer': apple_music_url
            }
            
            # Note: This is a simplified approach
            # Real implementation would need proper API token
            print(f"  üîç Trying API extraction for {content_type}: {content_id}")
            
            return None  # Skip API for now, use other methods
            
        except Exception as e:
            print(f"  ‚ö†Ô∏è  API extraction failed: {e}")
            return None
    
    def _extract_with_smart_fallback(self, apple_music_url):
        """Smart fallback that prompts user or uses intelligent parsing"""
        try:
            from bs4 import BeautifulSoup
            import re
            
            print("  üîç Using smart fallback extraction...")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Connection': 'keep-alive',
            }
            
            response = requests.get(apple_music_url, headers=headers, timeout=15)
            
            if response.status_code != 200:
                return None
            
            soup = BeautifulSoup(response.content, 'lxml' if 'lxml' in str(response.content) else 'html.parser')
            
            # Check if this is a single song (should NOT use smart fallback for single songs)
            if '/song/' in apple_music_url:
                print("  ‚ö†Ô∏è  This is a single song, skipping smart fallback (not a playlist)")
                return None
            
            # Try to get playlist title
            title = None
            title_selectors = [
                ('meta[property="og:title"]', 'content'),
                ('meta[property="twitter:title"]', 'content'),
                ('title', 'text'),
            ]
            
            for selector, attr_type in title_selectors:
                element = soup.select_one(selector)
                if element:
                    if attr_type == 'content':
                        title = element.get('content', '').strip()
                    else:
                        title = element.get_text().strip()
                    
                    if title:
                        title = title.replace(' - Apple Music', '').replace(' on Apple Music', '').strip()
                        break
            
            if not title:
                return None
            
            # For playlists/albums, check if this is from album download (no interactive prompt)
            # Albums from artist page should not prompt - just return title for search
            if '/album/' in apple_music_url:
                print(f"  üíø Found album: {title}")
                print(f"  ‚ÑπÔ∏è  Will search for complete album on YouTube")
                # Return basic metadata without tracks for album-as-whole search
                return {'title': title, 'tracks': []}
            
            # For playlists only, prompt user to provide track names
            print(f"\n  üìã Found playlist: {title}")
            print(f"  ‚ö†Ô∏è  Could not automatically extract track list due to JavaScript-heavy content")
            print(f"\n  üí° You have two options:")
            print(f"     1. Manually provide track names (one per line)")
            print(f"     2. Let me search for '{title}' as a whole playlist on YouTube")
            
            try:
                choice = input("\n  Choose option (1 or 2, default=2): ").strip()
                
                if choice == "1":
                    print("\n  Enter track names (format: 'Artist - Title', one per line)")
                    print("  Press Enter twice when done:")
                    tracks = []
                    while True:
                        line = input("  ").strip()
                        if not line:
                            break
                        if ' - ' in line:
                            artist, track_title = line.split(' - ', 1)
                            tracks.append({
                                'artist': artist.strip(),
                                'title': track_title.strip()
                            })
                        else:
                            tracks.append({
                                'artist': 'Unknown',
                                'title': line
                            })
                    
                    if tracks:
                        return {
                            'title': title,
                            'tracks': tracks
                        }
            except:
                pass
            
            # Option 2 or default: search as whole playlist
            return {
                'title': title,
                'tracks': []  # Empty will trigger playlist search
            }
            
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Smart fallback failed: {e}")
            return None
    
    def _extract_metadata_with_browser(self, apple_music_url):
        """Extract metadata using Selenium browser automation"""
        # Disabled - too unreliable across platforms
        return None
        
        try:
            driver = self._get_browser_driver()
            if not driver:
                return None
            
            print("üåê Loading Apple Music page with browser...")
            driver.get(apple_music_url)
            
            # Wait for content to load
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            
            # Give extra time for JavaScript to execute
            time.sleep(3)
            
            metadata = {}
            
            # Extract title
            title_selectors = [
                '[data-testid="song-name"]',
                '[data-testid="album-title"]', 
                '[data-testid="playlist-title"]',
                '.headings__title',
                '.product-header__title',
                'h1'
            ]
            
            for selector in title_selectors:
                try:
                    element = driver.find_element(By.CSS_SELECTOR, selector)
                    if element.text.strip():
                        metadata['title'] = element.text.strip()
                        break
                except:
                    continue
            
            # Extract artist/curator
            artist_selectors = [
                '[data-testid="click-action"]:first-of-type',
                '.headings__metadata a',
                '.product-header__subtitle a',
                '.songs-list-header__metadata a'
            ]
            
            for selector in artist_selectors:
                try:
                    element = driver.find_element(By.CSS_SELECTOR, selector)
                    if element.text.strip():
                        metadata['artist'] = element.text.strip()
                        metadata['curator'] = element.text.strip()
                        break
                except:
                    continue
            
            # Extract tracks (for albums/playlists)
            tracks = []
            track_selectors = [
                '[data-testid="track-list"] [data-testid="track-title"]',
                '.songs-list .song-name',
                '.tracklist-row .song-name'
            ]
            
            for selector in track_selectors:
                try:
                    track_elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    for track_elem in track_elements:
                        track_title = track_elem.text.strip()
                        if track_title:
                            # Try to find artist for this track
                            try:
                                artist_elem = track_elem.find_element(By.XPATH, "..//*[contains(@class, 'artist') or contains(@data-testid, 'artist')]")
                                track_artist = artist_elem.text.strip()
                            except:
                                track_artist = metadata.get('artist', 'Unknown Artist')
                            
                            tracks.append({
                                'title': track_title,
                                'artist': track_artist
                            })
                    
                    if tracks:
                        break
                except:
                    continue
            
            if tracks:
                metadata['tracks'] = tracks
            
            print(f"‚úÖ Browser extraction successful: {len(metadata)} fields")
            return metadata if metadata else None
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Browser extraction failed: {e}")
            return None
    
    def _extract_metadata_with_cloudscraper(self, apple_music_url):
        """Extract metadata using cloudscraper for Cloudflare bypass"""
        try:
            print("‚òÅÔ∏è  Trying cloudscraper extraction...")
            
            scraper = cloudscraper.create_scraper()
            response = scraper.get(apple_music_url, timeout=15)
            
            if response.status_code == 200:
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # Also save the raw response for debugging
                metadata = self._parse_apple_music_html(soup, response.text)
                return metadata
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Cloudscraper extraction failed: {e}")
            return None
    
    def _extract_metadata_enhanced_scraping(self, apple_music_url):
        """Enhanced web scraping with multiple strategies"""
        try:
            print("üï∑Ô∏è  Trying enhanced scraping...")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Cache-Control': 'max-age=0'
            }
            
            session = requests.Session()
            session.headers.update(headers)
            
            response = session.get(apple_music_url, timeout=15, allow_redirects=True)
            
            if response.status_code == 200:
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(response.content, 'html.parser')
                
                return self._parse_apple_music_html(soup, response.text)
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Enhanced scraping failed: {e}")
            return None
    
    def _parse_apple_music_html(self, soup, raw_html=None):
        """Parse Apple Music HTML to extract metadata"""
        metadata = {}
        tracks = []
        
        # If raw_html is provided, use it for more aggressive pattern matching
        if raw_html:
            try:
                import re
                import json
                
                # Try to find the main data object in the page
                # Apple Music embeds data in various formats
                
                # Pattern 1: Look for the serialized state data (most reliable)
                # This pattern captures the main data structure with all track info
                state_patterns = [
                    r'window\.__APOLLO_STATE__\s*=\s*(\{.+?\});\s*window',
                    r'window\.INIT_DATA\s*=\s*(\{.+?\});\s*window',
                    r'serializedState"\s*:\s*(\{.+?\})\s*,\s*"',
                ]
                
                for pattern in state_patterns:
                    state_match = re.search(pattern, raw_html, re.DOTALL)
                    if state_match:
                        try:
                            state_data = json.loads(state_match.group(1))
                            # Parse the state for track data
                            for key, value in state_data.items():
                                if isinstance(value, dict):
                                    # Check for track attributes
                                    attrs = value.get('attributes', value)
                                    if isinstance(attrs, dict):
                                        track_name = attrs.get('name', '')
                                        artist_name = attrs.get('artistName', '')
                                        
                                        # Also check for composerName as fallback
                                        if not artist_name:
                                            artist_name = attrs.get('composerName', '')
                                        
                                        if track_name and artist_name:
                                            # Avoid duplicates
                                            if not any(t['title'] == track_name and t['artist'] == artist_name for t in tracks):
                                                tracks.append({
                                                    'title': track_name,
                                                    'artist': artist_name
                                                })
                            
                            if tracks:
                                print(f"  ‚úÖ Extracted {len(tracks)} tracks from state data")
                                break
                        except Exception as e:
                            print(f"  ‚ö†Ô∏è  State parsing error: {e}")
                            continue
                
                # Pattern 2: Look for embedded JSON with track relationships
                # This is a more aggressive approach for newer Apple Music pages
                if not tracks:
                    try:
                        # Find all potential JSON objects that might contain track data
                        json_objects = re.findall(r'\{[^{}]*?"type"\s*:\s*"songs"[^{}]*?\}', raw_html)
                        json_objects += re.findall(r'\{[^{}]*?"attributes"\s*:\s*\{[^{}]*?"name"[^{}]*?"artistName"[^{}]*?\}[^{}]*?\}', raw_html)
                        
                        for json_str in json_objects:
                            try:
                                obj = json.loads(json_str)
                                attrs = obj.get('attributes', {})
                                track_name = attrs.get('name', '')
                                artist_name = attrs.get('artistName', '')
                                
                                if track_name and artist_name:
                                    if not any(t['title'] == track_name and t['artist'] == artist_name for t in tracks):
                                        tracks.append({
                                            'title': track_name,
                                            'artist': artist_name
                                        })
                            except:
                                continue
                        
                        if tracks:
                            print(f"  ‚úÖ Extracted {len(tracks)} tracks from embedded JSON objects")
                    except Exception as e:
                        print(f"  ‚ö†Ô∏è  JSON object parsing error: {e}")
                
                # Pattern 3: Direct regex extraction (most aggressive, last resort)
                # IMPORTANT: In Apple Music HTML, artistName comes BEFORE title in the structure!
                if not tracks:
                    try:
                        # Pattern 1: artistName before title (this is the correct order for Apple Music)
                        # Use a pattern that handles escaped quotes within strings
                        artist_title_pattern = r'"artistName"\s*:\s*"((?:[^"\\]|\\.)*)".{0,2000}?"title"\s*:\s*"((?:[^"\\]|\\.)*)"'
                        matches = re.findall(artist_title_pattern, raw_html, re.DOTALL)
                        
                        for artist_name, track_name in matches:
                            # Filter out non-track data
                            if track_name and artist_name:
                                # Clean up escaped characters in track names
                                # Replace escaped quotes and backslashes
                                track_name = track_name.replace(r'\"', '"').replace(r'\\', '\\').strip()
                                artist_name = artist_name.replace(r'\"', '"').replace(r'\\', '\\').strip()
                                
                                if track_name.lower() not in ['music', 'playlist', 'album', 'artist']:
                                    # Check for duplicates using normalized comparison
                                    if not any(t['title'].lower() == track_name.lower() and t['artist'].lower() == artist_name.lower() for t in tracks):
                                        tracks.append({
                                            'title': track_name,
                                            'artist': artist_name
                                        })
                        
                        if tracks:
                            print(f"  ‚úÖ Extracted {len(tracks)} tracks using artistName+title pattern")
                        
                        # Pattern 2: Fallback - try the reverse order (name before artistName)
                        if not tracks:
                            name_artist_pattern = r'"name"\s*:\s*"([^"]+)".{0,2000}?"artistName"\s*:\s*"([^"]+)"'
                            matches = re.findall(name_artist_pattern, raw_html, re.DOTALL)
                            
                            for track_name, artist_name in matches:
                                if track_name and artist_name:
                                    # Clean up escaped characters
                                    track_name = track_name.replace('\\', '').strip()
                                    artist_name = artist_name.strip()
                                    
                                    if track_name.lower() not in ['music', 'playlist', 'album', 'artist']:
                                        # Check for duplicates using normalized comparison
                                        if not any(t['title'].lower() == track_name.lower() and t['artist'].lower() == artist_name.lower() for t in tracks):
                                            tracks.append({
                                                'title': track_name,
                                                'artist': artist_name
                                            })
                            
                            if tracks:
                                print(f"  ‚úÖ Extracted {len(tracks)} tracks using name+artistName pattern")
                    except Exception as e:
                        print(f"  ‚ö†Ô∏è  Regex extraction error: {e}")
                        
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Raw HTML parsing failed: {e}")
        
        # Extract title from various sources
        title_sources = [
            ('meta[property="og:title"]', 'content'),
            ('meta[name="twitter:title"]', 'content'),
            ('title', 'text'),
            ('.headings__title', 'text'),
            ('.product-header__title', 'text'),
            ('h1', 'text')
        ]
        
        for selector, attr_type in title_sources:
            element = soup.select_one(selector)
            if element:
                if attr_type == 'content':
                    title = element.get('content', '').strip()
                else:
                    title = element.get_text().strip()
                
                if title:
                    # Clean up title
                    title = title.replace(' - Apple Music', '').replace(' on Apple Music', '')
                    title = title.replace('‚Äé', '').strip()
                    if title and len(title) > 2:
                        metadata['title'] = title
                        break
        
        # Extract artist/curator
        artist_sources = [
            ('meta[name="music:musician"]', 'content'),
            ('.headings__metadata a', 'text'),
            ('.product-header__subtitle a', 'text'),
            ('.songs-list-header__metadata a', 'text')
        ]
        
        for selector, attr_type in artist_sources:
            element = soup.select_one(selector)
            if element:
                if attr_type == 'content':
                    artist = element.get('content', '').strip()
                else:
                    artist = element.get_text().strip()
                
                if artist:
                    metadata['artist'] = artist
                    metadata['curator'] = artist
                    break
        
        # Extract structured data for tracks from JSON-LD
        scripts = soup.find_all('script', type='application/ld+json')
        for script in scripts:
            try:
                import json
                data = json.loads(script.string)
                
                if isinstance(data, dict):
                    # Handle MusicAlbum or MusicPlaylist
                    if data.get('@type') in ['MusicAlbum', 'MusicPlaylist'] and 'track' in data:
                        for track_data in data['track']:
                            if isinstance(track_data, dict):
                                track_title = track_data.get('name', '')
                                track_artist = ''
                                
                                if 'byArtist' in track_data:
                                    if isinstance(track_data['byArtist'], dict):
                                        track_artist = track_data['byArtist'].get('name', '')
                                    elif isinstance(track_data['byArtist'], list) and track_data['byArtist']:
                                        track_artist = track_data['byArtist'][0].get('name', '')
                                
                                if track_title:
                                    tracks.append({
                                        'title': track_title,
                                        'artist': track_artist or metadata.get('artist', 'Unknown Artist')
                                    })
                        
                        if tracks:
                            break
            except Exception as e:
                continue
        
        # Additional fallback: Try to extract from script tags if raw_html extraction didn't work
        if not tracks:
            try:
                # Look for embedded JSON data in script tags
                all_scripts = soup.find_all('script')
                for script in all_scripts:
                    if script.string and len(script.string) > 100:  # Skip very small scripts
                        import re
                        import json
                        
                        # Strategy 1: Look for track arrays with relationships
                        try:
                            # Pattern for track data in relationships structure
                            relationships_pattern = r'"relationships"\s*:\s*\{[^}]*"tracks"\s*:\s*\{[^}]*"data"\s*:\s*\[(.*?)\]'
                            rel_match = re.search(relationships_pattern, script.string, re.DOTALL)
                            
                            if rel_match:
                                # Try to find corresponding attributes
                                attrs_pattern = r'"id"\s*:\s*"([^"]+)"[^}]*"attributes"\s*:\s*\{[^}]*"name"\s*:\s*"([^"]+)"[^}]*"artistName"\s*:\s*"([^"]+)"'
                                attr_matches = re.findall(attrs_pattern, script.string)
                                
                                for track_id, track_name, artist_name in attr_matches:
                                    if track_name and artist_name:
                                        if not any(t['title'] == track_name and t['artist'] == artist_name for t in tracks):
                                            tracks.append({
                                                'title': track_name,
                                                'artist': artist_name
                                            })
                                
                                if tracks:
                                    print(f"  ‚úÖ Extracted {len(tracks)} tracks from relationships data")
                                    break
                        except:
                            pass
                        
                        # Strategy 2: Direct extraction with better context
                        if not tracks:
                            try:
                                # Look for track objects in arrays
                                # Pattern: Find arrays that contain track-like objects
                                array_pattern = r'\[(\{[^]]+?"name"\s*:\s*"[^"]+?"[^]]+?"artistName"\s*:\s*"[^"]+?"[^]]+?\}(?:,\s*\{[^]]+?\})*)\]'
                                array_matches = re.findall(array_pattern, script.string)
                                
                                for array_content in array_matches:
                                    # Extract individual track objects
                                    track_pattern = r'"name"\s*:\s*"([^"]+)"[^}]*?"artistName"\s*:\s*"([^"]+)"'
                                    track_matches = re.findall(track_pattern, array_content)
                                    
                                    for track_name, artist_name in track_matches:
                                        if track_name and artist_name:
                                            if track_name.lower() not in ['music', 'playlist', 'album']:
                                                if not any(t['title'] == track_name and t['artist'] == artist_name for t in tracks):
                                                    tracks.append({
                                                        'title': track_name,
                                                        'artist': artist_name
                                                    })
                                
                                if tracks:
                                    print(f"  ‚úÖ Extracted {len(tracks)} tracks from array structures")
                                    break
                            except:
                                pass
            except Exception as e:
                print(f"  ‚ö†Ô∏è  Error parsing embedded data: {e}")
        
        # Final deduplication pass - remove any duplicate tracks
        # Smart deduplication: prefer tracks with real artist names over "Unknown Artist"
        if tracks:
            # First pass: collect tracks by title
            tracks_by_title = {}
            for track in tracks:
                title_lower = track['title'].lower().strip()
                artist = track['artist'].strip()
                
                if title_lower not in tracks_by_title:
                    tracks_by_title[title_lower] = track
                else:
                    # If we already have this title, prefer the one with a real artist
                    existing = tracks_by_title[title_lower]
                    if existing['artist'] == 'Unknown Artist' and artist != 'Unknown Artist':
                        # Replace with the version that has artist info
                        tracks_by_title[title_lower] = track
                    elif existing['artist'] != 'Unknown Artist' and artist == 'Unknown Artist':
                        # Keep the existing one with artist info
                        pass
                    elif existing['artist'].lower() != artist.lower():
                        # Different artists for same title - keep both
                        # Create a unique key
                        key_counter = 1
                        unique_title = f"{title_lower}_{key_counter}"
                        while unique_title in tracks_by_title:
                            key_counter += 1
                            unique_title = f"{title_lower}_{key_counter}"
                        tracks_by_title[unique_title] = track
            
            unique_tracks = list(tracks_by_title.values())
            
            if len(unique_tracks) < len(tracks):
                print(f"  ‚ÑπÔ∏è  Removed {len(tracks) - len(unique_tracks)} duplicate tracks")
            
            tracks = unique_tracks
            metadata['tracks'] = tracks
        
        return metadata if metadata else None
    
    def _prompt_playlist_download_choice_enhanced(self, tracks):
        """Enhanced playlist download choice with better formatting"""
        print(f"\nüéµ Playlist contains {len(tracks)} tracks")
        print("üì• Download options:")
        print("  1. Download all tracks")
        print("  2. Select specific tracks")
        print("  3. Download first 10 tracks only")
        print("  4. Cancel")
        
        while True:
            try:
                choice = input("\nEnter your choice (1-4): ").strip()
                
                if choice == "1":
                    return "all"
                elif choice == "2":
                    return self._select_specific_tracks_enhanced(tracks)
                elif choice == "3":
                    return tracks[:10]
                elif choice == "4":
                    return "cancel"
                else:
                    print("Please enter 1, 2, 3, or 4")
                    
            except KeyboardInterrupt:
                return "cancel"
    
    def _select_specific_tracks_enhanced(self, tracks):
        """Enhanced track selection with better interface"""
        print(f"\nüìã Available tracks ({len(tracks)} total):")
        
        # Show tracks in batches for better readability
        batch_size = 20
        for i in range(0, len(tracks), batch_size):
            batch = tracks[i:i+batch_size]
            print(f"\n--- Tracks {i+1}-{min(i+batch_size, len(tracks))} ---")
            
            for j, track in enumerate(batch, i+1):
                artist = track.get('artist', 'Unknown Artist')
                title = track.get('title', 'Unknown Title')
                print(f"  {j:3d}. {artist} - {title}")
            
            if i + batch_size < len(tracks):
                input("Press Enter to see more tracks...")
        
        print(f"\nüìù Selection options:")
        print("  ‚Ä¢ Individual numbers: 1,3,5,10")
        print("  ‚Ä¢ Ranges: 1-10,15-20") 
        print("  ‚Ä¢ Mixed: 1,3,5-8,10,12-15")
        print("  ‚Ä¢ Type 'all' for all tracks")
        print("  ‚Ä¢ Type 'cancel' to cancel")
        
        try:
            user_input = input("Your selection: ").strip().lower()
            
            if user_input == 'cancel':
                return "cancel"
            elif user_input == 'all':
                return tracks
            
            # Parse selection
            selected_indices = set()
            
            for part in user_input.split(','):
                part = part.strip()
                if '-' in part:
                    try:
                        start, end = map(int, part.split('-'))
                        selected_indices.update(range(start-1, end))
                    except ValueError:
                        print(f"‚ö†Ô∏è  Invalid range: {part}")
                else:
                    try:
                        selected_indices.add(int(part) - 1)
                    except ValueError:
                        print(f"‚ö†Ô∏è  Invalid number: {part}")
            
            # Filter valid indices
            valid_indices = [i for i in selected_indices if 0 <= i < len(tracks)]
            selected_tracks = [tracks[i] for i in sorted(valid_indices)]
            
            if selected_tracks:
                print(f"‚úÖ Selected {len(selected_tracks)} tracks")
                return selected_tracks
            else:
                print("‚ùå No valid tracks selected")
                return "cancel"
                
        except KeyboardInterrupt:
            return "cancel"
    
    def _download_track_queue_enhanced(self, tracks, source_name):
        """Enhanced track queue download with better progress tracking"""
        if not tracks:
            return False
        
        print("\n" + "=" * 60)
        print(f"üéµ Starting {source_name} Download Queue")
        print(f"üìä Total tracks: {len(tracks)}")
        print("=" * 60)
        
        successful_downloads = 0
        failed_downloads = 0
        
        for i, track in enumerate(tracks, 1):
            try:
                artist = track.get('artist', 'Unknown Artist')
                title = track.get('title', 'Unknown Title')
                # Search with "Title - Artist" format
                search_query = f"{title} - {artist}"
                # Filename with "Artist - Title" format
                filename = f"{artist} - {title}"
                
                print(f"\nüéµ [{i:3d}/{len(tracks)}] {title}")
                print(f"    üë§ {artist}")
                print("    " + "‚îÄ" * 50)
                
                # Use enhanced music search
                youtube_url = self._search_youtube_for_music(search_query)
                
                if youtube_url:
                    print(f"    ‚úÖ Found: {youtube_url}")
                    
                    result = self.download_media(
                        youtube_url,
                        audio_only=True,
                        output_format='mp3',  # Use MP3 for better compatibility
                        add_metadata=True,
                        add_thumbnail=True,
                        custom_filename=filename  # Save as "Artist - Title"
                    )
                    
                    if result:
                        successful_downloads += 1
                        print(f"    ‚úÖ Download successful!")
                    else:
                        failed_downloads += 1
                        print(f"    ‚ùå Download failed")
                else:
                    failed_downloads += 1
                    print(f"    ‚ùå Not found on YouTube")
                
                # Progress indicator
                progress = (i / len(tracks)) * 100
                print(f"    üìà Progress: {progress:.1f}% ({successful_downloads} successful, {failed_downloads} failed)")
                
                # Small delay between downloads
                if i < len(tracks):
                    time.sleep(1)
                    
            except Exception as e:
                failed_downloads += 1
                print(f"    ‚ùå Error: {e}")
        
        # Final summary
        print("\n" + "=" * 60)
        print(f"üéµ {source_name} Download Queue Complete!")
        print(f"‚úÖ Successful: {successful_downloads}")
        print(f"‚ùå Failed: {failed_downloads}")
        print(f"üìà Success rate: {(successful_downloads/len(tracks)*100):.1f}%")
        print(f"üìÇ Location: {self.output_dir}")
        print("=" * 60)
        
        return successful_downloads > 0
    
    def cleanup(self):
        """Cleanup resources"""
        if self.browser_driver:
            try:
                self.browser_driver.quit()
                print("üßπ Browser driver cleaned up")
            except:
                pass
            self.browser_driver = None
    
    def __del__(self):
        """Destructor to ensure cleanup"""
        self.cleanup()
    
    def signal_handler(self, signum, frame):
        """Handle interruption signals"""
        print("\n\nDownload interrupted by user. Cleaning up...")
        self.cancelled = True
        sys.exit(0)
    
    def setup_signal_handlers(self):
        """Setup signal handlers for graceful interruption"""
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
    
    def clean_url(self, url):
        """Clean and normalize URLs"""
        # Remove playlist parameters that might cause issues for single video downloads
        if "youtube.com" in url or "youtu.be" in url:
            if "&list=" in url and "watch?v=" in url:
                # For YouTube, if it's a single video in a playlist, extract just the video
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                if 'v' in params:
                    video_id = params['v'][0]
                    return f"https://www.youtube.com/watch?v={video_id}"
        return url
    
    def _fetch_spotify_album_art(self, track_name, artist_name, silent=False):
        """Fetch high-quality album art from Spotify"""
        if not self.spotify_client:
            return None
        
        try:
            if not silent:
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"[dim cyan]‚Üí[/dim cyan] [dim]Fetching album art from Spotify...[/dim]", end="\r")
                else:
                    print(f"‚Üí Fetching album art from Spotify...", end="\r")
            
            query = f"{track_name} {artist_name}"
            results = self.spotify_client.search(q=query, type='track', limit=1)
            
            if results and results['tracks']['items']:
                track = results['tracks']['items'][0]
                album = track['album']
                
                # Get the highest quality image (first one is usually largest)
                if album['images']:
                    image_url = album['images'][0]['url']
                    
                    # Download the image
                    response = requests.get(image_url, timeout=10)
                    if response.status_code == 200:
                        return response.content
            
            return None
            
        except Exception as e:
            return None
    
    def _fetch_apple_music_album_art(self, track_name, artist_name, silent=False):
        """Fetch high-quality album art from Apple Music API"""
        try:
            if not silent:
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"[dim cyan]‚Üí[/dim cyan] [dim]Fetching album art from Apple Music...[/dim]", end="\r")
                else:
                    print(f"‚Üí Fetching album art from Apple Music...", end="\r")
            
            # Use Apple Music Search API (doesn't require authentication)
            base_url = "https://itunes.apple.com/search"
            params = {
                'term': f"{artist_name} {track_name}",
                'media': 'music',
                'entity': 'song',
                'limit': 1
            }
            
            response = requests.get(base_url, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                
                if data.get('results'):
                    result = data['results'][0]
                    # Apple Music provides artwork URLs, usually at 100x100, but we can request higher res
                    artwork_url = result.get('artworkUrl100', '').replace('100x100', '600x600')
                    
                    if artwork_url:
                        art_response = requests.get(artwork_url, timeout=10)
                        if art_response.status_code == 200:
                            return art_response.content
            
            return None
            
        except Exception as e:
            return None
    
    def _embed_album_art(self, audio_file_path, album_art_data, track_info=None, silent=False):
        """Embed album art into audio file with proper metadata"""
        if not MUTAGEN_AVAILABLE:
            if not silent:
                if RICH_AVAILABLE and self.console:
                    self.console.print("[yellow]‚ö†[/yellow] Mutagen not available, skipping album art embedding")
                else:
                    print("‚ö† Mutagen not available, skipping album art embedding")
            return False
        
        try:
            file_path = Path(audio_file_path)
            file_ext = file_path.suffix.lower()
            
            if file_ext == '.mp3':
                audio = MP3(str(file_path), ID3=ID3)
                
                # Add ID3 tag if doesn't exist
                try:
                    audio.add_tags()
                except:
                    pass
                
                # Add cover art
                audio.tags.add(
                    APIC(
                        encoding=3,
                        mime='image/jpeg',
                        type=3,  # Cover (front)
                        desc='Cover',
                        data=album_art_data
                    )
                )
                
                # Add track info if provided
                if track_info:
                    if track_info.get('title'):
                        audio.tags.add(TIT2(encoding=3, text=track_info['title']))
                    if track_info.get('artist'):
                        audio.tags.add(TPE1(encoding=3, text=track_info['artist']))
                    if track_info.get('album'):
                        audio.tags.add(TALB(encoding=3, text=track_info['album']))
                    if track_info.get('year'):
                        audio.tags.add(TDRC(encoding=3, text=str(track_info['year'])))
                
                audio.save()
                return True
                
            elif file_ext == '.flac':
                audio = FLAC(str(file_path))
                
                # Create Picture object for FLAC
                picture = Picture()
                picture.type = 3  # Cover (front)
                picture.mime = 'image/jpeg'
                picture.desc = 'Cover'
                picture.data = album_art_data
                
                # Remove existing pictures
                audio.clear_pictures()
                audio.add_picture(picture)
                
                # Add track info if provided
                if track_info:
                    if track_info.get('title'):
                        audio['title'] = track_info['title']
                    if track_info.get('artist'):
                        audio['artist'] = track_info['artist']
                    if track_info.get('album'):
                        audio['album'] = track_info['album']
                    if track_info.get('year'):
                        audio['date'] = str(track_info['year'])
                
                audio.save()
                return True
                
            elif file_ext in ['.m4a', '.mp4']:
                audio = MP4(str(file_path))
                
                # Add cover art
                audio['covr'] = [MP4Cover(album_art_data, imageformat=MP4Cover.FORMAT_JPEG)]
                
                # Add track info if provided
                if track_info:
                    if track_info.get('title'):
                        audio['\xa9nam'] = track_info['title']
                    if track_info.get('artist'):
                        audio['\xa9ART'] = track_info['artist']
                    if track_info.get('album'):
                        audio['\xa9alb'] = track_info['album']
                    if track_info.get('year'):
                        audio['\xa9day'] = str(track_info['year'])
                
                audio.save()
                return True
            
            else:
                if not silent:
                    if RICH_AVAILABLE and self.console:
                        self.console.print(f"[yellow]‚ö†[/yellow] Album art embedding not supported for {file_ext} format")
                    else:
                        print(f"‚ö† Album art embedding not supported for {file_ext} format")
                return False
                
        except Exception as e:
            if not silent:
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"[red]‚úó[/red] Error embedding album art: {e}")
                else:
                    print(f"‚úó Error embedding album art: {e}")
            return False
    
    def _convert_to_true_lossless(self, audio_file_path, target_format='flac'):
        """Convert audio to true lossless format using FFmpeg with proper settings"""
        try:
            file_path = Path(audio_file_path)
            
            # Check if source is already lossless
            source_ext = file_path.suffix.lower()
            if source_ext in ['.flac', '.wav', '.alac']:
                print(f"‚úÖ Source is already in lossless format: {source_ext}")
                return str(file_path)
            
            # For lossy sources, we can't create "true" lossless, but we can ensure best quality conversion
            if source_ext in ['.mp3', '.m4a', '.aac', '.opus', '.ogg']:
                print(f"‚ö†Ô∏è  Source is lossy ({source_ext}). Converting to {target_format} for archival...")
                print(f"üí° Note: This won't improve quality, but provides better format for storage")
            
            output_file = file_path.with_suffix(f'.{target_format}')
            
            print(f"üîÑ Converting {file_path.name} to {target_format.upper()}...")
            
            if target_format == 'flac':
                # FLAC with maximum compression (level 8) for best size/quality ratio
                cmd = [
                    'ffmpeg', '-i', str(file_path),
                    '-c:a', 'flac',
                    '-compression_level', '8',
                    '-sample_fmt', 's32',  # 32-bit depth
                    '-ar', '48000',  # 48kHz sample rate
                    str(output_file),
                    '-y'  # Overwrite output file
                ]
            elif target_format == 'wav':
                # WAV with high bit depth
                cmd = [
                    'ffmpeg', '-i', str(file_path),
                    '-c:a', 'pcm_s24le',  # 24-bit PCM
                    '-ar', '48000',  # 48kHz sample rate
                    str(output_file),
                    '-y'
                ]
            else:
                print(f"‚ùå Unsupported target format: {target_format}")
                return str(file_path)
            
            # Run FFmpeg conversion
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            if result.returncode == 0 and output_file.exists():
                print(f"‚úÖ Converted to {target_format.upper()}: {output_file.name}")
                
                # Remove original file if conversion successful
                try:
                    file_path.unlink()
                    print(f"üóëÔ∏è  Removed original file: {file_path.name}")
                except:
                    pass
                
                return str(output_file)
            else:
                print(f"‚ùå Conversion failed: {result.stderr}")
                return str(file_path)
                
        except subprocess.TimeoutExpired:
            print(f"‚ùå Conversion timeout exceeded")
            return str(file_path)
        except Exception as e:
            print(f"‚ùå Error during conversion: {e}")
            return str(file_path)
                
    def _add_album_art_to_playlist(self, playlist_dir):
        """Add album art to all audio files in a playlist directory"""
        try:
            playlist_path = Path(playlist_dir)
            if not playlist_path.exists():
                return
            
            # Find all audio files
            audio_files = []
            for ext in ['.flac', '.mp3', '.m4a', '.aac']:
                audio_files.extend(playlist_path.glob(f'*{ext}'))
            
            if not audio_files:
                return
            
            if RICH_AVAILABLE and self.console:
                self.console.print(f"\n[bold cyan]‚ô™[/bold cyan] Processing album artwork for {len(audio_files)} files...")
            else:
                print(f"\n‚ô™ Processing album artwork for {len(audio_files)} files...")
            
            # Process each file
            for idx, audio_file in enumerate(audio_files, 1):
                try:
                    # Extract track info from filename (format: "001 - Artist - Title.ext")
                    filename = audio_file.stem
                    
                    # Try to parse title and artist from filename
                    # Common patterns: "001 - Title", "001 - Artist - Title"
                    parts = filename.split(' - ', 1)
                    if len(parts) > 1:
                        track_name = parts[1].strip()
                        
                        # Try to split artist and title
                        if ' - ' in track_name:
                            artist_parts = track_name.split(' - ', 1)
                            artist_name = artist_parts[0].strip()
                            track_title = artist_parts[1].strip()
                        else:
                            artist_name = ""
                            track_title = track_name
                    else:
                        track_title = filename
                        artist_name = ""
                    
                    if RICH_AVAILABLE and self.console:
                        self.console.print(f"[dim][{idx}/{len(audio_files)}][/dim] [cyan]{track_title}[/cyan]", end="")
                    else:
                        print(f"[{idx}/{len(audio_files)}] {track_title}", end="")
                    
                    # Try to fetch album art from Apple Music first, then Spotify
                    album_art_data = None
                    if track_title:
                        album_art_data = self._fetch_apple_music_album_art(track_title, artist_name, silent=True)
                        
                        if not album_art_data and self.spotify_client:
                            album_art_data = self._fetch_spotify_album_art(track_title, artist_name, silent=True)
                    
                    # Embed album art if found
                    if album_art_data:
                        track_info = {
                            'title': track_title,
                            'artist': artist_name if artist_name else 'Unknown',
                        }
                        self._embed_album_art(str(audio_file), album_art_data, track_info, silent=True)
                        if RICH_AVAILABLE and self.console:
                            self.console.print(f" [green]‚úì[/green]")
                        else:
                            print(f" ‚úì")
                    else:
                        if RICH_AVAILABLE and self.console:
                            self.console.print(f" [yellow]‚äò[/yellow]")
                        else:
                            print(f" ‚äò")
                    
                except Exception as e:
                    if RICH_AVAILABLE and self.console:
                        self.console.print(f" [red]‚úó[/red] ({str(e)})")
                    else:
                        print(f" ‚úó ({str(e)})")
                    continue
            
            if RICH_AVAILABLE and self.console:
                self.console.print(f"[bold green]‚úì[/bold green] Album artwork processing completed")
            else:
                print(f"‚úì Album artwork processing completed")
                
        except Exception as e:
            if RICH_AVAILABLE and self.console:
                self.console.print(f"[yellow]‚ö†[/yellow] Error processing album art: {str(e)}")
            else:
                print(f"‚ö† Error processing album art: {str(e)}")
    
    def _enhance_audio_with_metadata(self, audio_file_path, track_name, artist_name, fetch_from_streaming=True):
        """Enhance audio file with proper metadata and album art from streaming services"""
        try:
            print(f"\nüéµ Enhancing audio metadata for: {track_name}")
            
            # Try to fetch album art from streaming services
            album_art_data = None
            
            if fetch_from_streaming:
                # Try Spotify first (usually better quality)
                if SPOTIFY_AVAILABLE and self.spotify_client:
                    album_art_data = self._fetch_spotify_album_art(track_name, artist_name)
                
                # If Spotify fails, try Apple Music
                if not album_art_data:
                    album_art_data = self._fetch_apple_music_album_art(track_name, artist_name)
            
            # If we got album art, embed it
            if album_art_data:
                track_info = {
                    'title': track_name,
                    'artist': artist_name,
                }
                self._embed_album_art(audio_file_path, album_art_data, track_info)
            else:
                print("‚ö†Ô∏è  Using YouTube thumbnail as fallback")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error enhancing audio metadata: {e}")
            return False

    def is_playlist_url(self, url):
        """Detect if URL is a playlist"""
        playlist_indicators = [
            'list=',  # YouTube playlists
            'playlist',  # Generic playlist
            'album',  # Spotify albums
            'sets/',  # SoundCloud sets
            '/playlists/',  # Various platforms
        ]
        
        url_lower = url.lower()
        return any(indicator in url_lower for indicator in playlist_indicators)
    
    def prompt_user_choice(self, prompt, choices, default=None):
        """Prompt user for a choice from a list"""
        print(f"\n{prompt}")
        for i, choice in enumerate(choices, 1):
            marker = " (default)" if default and choice == default else ""
            print(f"  {i}. {choice}{marker}")
        
        while True:
            try:
                choice = input(f"\nEnter your choice (1-{len(choices)}): ").strip()
                if not choice and default:
                    return default
                
                choice_idx = int(choice) - 1
                if 0 <= choice_idx < len(choices):
                    return choices[choice_idx]
                else:
                    print(f"Please enter a number between 1 and {len(choices)}")
            except (ValueError, KeyboardInterrupt):
                if default:
                    return default
                print(f"Please enter a number between 1 and {len(choices)}")
    
    def prompt_format_selection(self, url):
        """Interactive format selection"""
        print("\nüéØ FORMAT SELECTION")
        print("=" * 50)
        
        # Ask for media type
        media_types = ["Video (with audio)", "Audio only"]
        media_choice = self.prompt_user_choice(
            "What type of media do you want to download?", 
            media_types, 
            default="Video (with audio)"
        )
        
        audio_only = media_choice == "Audio only"
        
        # Ask for quality with enhanced audio format options
        if audio_only:
            quality_options = [
                "Best lossless (FLAC)",
                "High quality (Opus 256kbps)", 
                "High quality (M4A 256kbps)",
                "Standard (MP3 320kbps)", 
                "Compact (MP3 192kbps)",
                "Custom"
            ]
            quality_choice = self.prompt_user_choice(
                "Select audio quality and format:", 
                quality_options, 
                default="Best lossless (FLAC)"
            )
            
            if quality_choice == "Custom":
                print("\nCustom format examples:")
                print("  FLAC lossless: bestaudio[acodec=flac]/bestaudio")
                print("  Opus high quality: bestaudio[acodec=opus]/bestaudio")
                print("  M4A/AAC: bestaudio[acodec=m4a]/bestaudio[acodec=aac]")
                custom_format = input("Enter custom format: ").strip()
                return "best", audio_only, None, custom_format if custom_format else None
            
            quality_map = {
                "Best lossless (FLAC)": "best",
                "High quality (Opus 256kbps)": "best", 
                "High quality (M4A 256kbps)": "best",
                "Standard (MP3 320kbps)": "best",
                "Compact (MP3 192kbps)": "best"
            }
            
            format_map = {
                "Best lossless (FLAC)": "flac",
                "High quality (Opus 256kbps)": "opus", 
                "High quality (M4A 256kbps)": "m4a",
                "Standard (MP3 320kbps)": "mp3",
                "Compact (MP3 192kbps)": "mp3"
            }
            
            return quality_map[quality_choice], audio_only, format_map[quality_choice], None
        else:
            quality_options = ["Best available", "4K (2160p)", "1440p", "1080p", "720p", "480p", "360p", "Custom"]
            quality_choice = self.prompt_user_choice(
                "Select video quality:", 
                quality_options, 
                default="Best available"
            )
            
            if quality_choice == "Custom":
                custom_format = input("Enter custom format (e.g., 'best[height<=720]'): ").strip()
                return "best", audio_only, None, custom_format if custom_format else None
            
            quality_map = {
                "Best available": "best",
                "4K (2160p)": "2160p",
                "1440p": "1440p", 
                "1080p": "1080p",
                "720p": "720p",
                "480p": "480p",
                "360p": "360p"
            }
            
            # Ask for output format
            format_options = ["MP4 (recommended)", "MKV", "WebM", "AVI", "MOV", "Keep original"]
            format_choice = self.prompt_user_choice(
                "Select output format:", 
                format_options, 
                default="MP4 (recommended)"
            )
            
            format_map = {
                "MP4 (recommended)": "mp4",
                "MKV": "mkv",
                "WebM": "webm", 
                "AVI": "avi",
                "MOV": "mov",
                "Keep original": None
            }
            
            return quality_map[quality_choice], audio_only, format_map[format_choice], None
    
    def get_supported_formats(self, url, timeout=30):
        """Get all available formats for a URL with timeout"""
        def extract_formats():
            ydl_opts = self.default_ydl_opts.copy()
            ydl_opts.update({
                'quiet': True,
                'listformats': True,
                'extract_flat': False,
            })
            
            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(url, download=False)
                    return info
            except Exception as e:
                print(f"Error extracting formats: {e}")
                return None
        
        # Use threading with timeout
        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(extract_formats)
            try:
                result = future.result(timeout=timeout)
                return result
            except TimeoutError:
                print(f"Format extraction timed out after {timeout} seconds")
                return None
            except Exception as e:
                print(f"Error in format extraction: {e}")
                return None
    
    def display_available_qualities(self, info):
        """Display available video and audio qualities"""
        if not info or 'formats' not in info:
            print("No format information available")
            return
        
        formats = info['formats']
        
        # Separate video and audio formats
        video_formats = []
        audio_formats = []
        
        for fmt in formats:
            if fmt.get('vcodec') != 'none' and fmt.get('height'):
                video_formats.append(fmt)
            elif fmt.get('acodec') != 'none' and fmt.get('vcodec') == 'none':
                audio_formats.append(fmt)
        
        print("\n" + "="*70)
        print(f"üìπ AVAILABLE VIDEO QUALITIES ({len(video_formats)} formats)")
        print("="*70)
        
        # Sort video formats by quality (height)
        video_formats.sort(key=lambda x: x.get('height', 0), reverse=True)
        
        for i, fmt in enumerate(video_formats[:15]):  # Show top 15
            height = fmt.get('height', 'Unknown')
            fps = fmt.get('fps', 'Unknown')
            vcodec = fmt.get('vcodec', 'Unknown')[:20]  # Truncate long codec names
            filesize = fmt.get('filesize')
            ext = fmt.get('ext', 'Unknown')
            format_id = fmt.get('format_id', 'Unknown')
            
            size_str = f"{filesize / 1024 / 1024:.1f}MB" if filesize else "Unknown size"
            
            print(f"{i+1:2d}. {height:4}p @{fps:4}fps | {vcodec:20} | {ext:4} | {size_str:12} | ID: {format_id}")
        
        print("\n" + "="*70)
        print(f"üéµ AVAILABLE AUDIO QUALITIES ({len(audio_formats)} formats)")
        print("="*70)
        
        # Sort audio formats by quality (abr - audio bitrate)
        audio_formats.sort(key=lambda x: x.get('abr', 0), reverse=True)
        
        for i, fmt in enumerate(audio_formats[:15]):  # Show top 15
            abr = fmt.get('abr', 'Unknown')
            acodec = fmt.get('acodec', 'Unknown')[:20]
            ext = fmt.get('ext', 'Unknown')
            filesize = fmt.get('filesize')
            format_id = fmt.get('format_id', 'Unknown')
            
            size_str = f"{filesize / 1024 / 1024:.1f}MB" if filesize else "Unknown size"
            bitrate_str = f"{abr:6.1f}kbps" if abr != 'Unknown' else "Unknown   "
            
            print(f"{i+1:2d}. {bitrate_str} | {acodec:20} | {ext:4} | {size_str:12} | ID: {format_id}")
        
        # Show recommended formats
        print("\n" + "="*70)
        print("üåü RECOMMENDED FORMATS")
        print("="*70)
        print("üé• Best video quality:     bestvideo+bestaudio/best")
        print("üéµ Best audio quality:     bestaudio/best")
        print("üì∫ 1080p video:           best[height<=1080]")
        print("üì∫ 720p video:            best[height<=720]")
        print("üéß MP3 audio (320kbps):   bestaudio[abr>=320]/bestaudio")
        print("üéß High quality audio:    bestaudio[ext=m4a]/bestaudio")
        print("\nüí° Pro tip: Use --custom-format to specify exact format IDs")
    
    def get_video_info(self, url, timeout=45):
        """Get comprehensive video information with timeout"""
        # Handle special platforms
        platform = self.detect_platform(url)
        
        if platform == 'spotify':
            return self.search_and_download_spotify_track(url)
        
        def extract_info():
            # Clean the URL first
            clean_url = self.clean_url(url)
            
            ydl_opts = self.default_ydl_opts.copy()
            ydl_opts.update({
                'quiet': True,
                'extract_flat': False,
            })
            
            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    print("üîç Extracting media information...")
                    info = ydl.extract_info(clean_url, download=False)
                    return info
            except Exception as e:
                print(f"Error extracting info: {e}")
                return None
        
        # Progress indicator
        def show_progress():
            chars = "|/-\\"
            i = 0
            start_time = time.time()
            while not hasattr(extract_info, 'done'):
                elapsed = int(time.time() - start_time)
                print(f"\r‚è≥ Loading {chars[i % len(chars)]} ({elapsed}s)", end="", flush=True)
                i += 1
                time.sleep(0.5)
        
        # Use threading with timeout
        with ThreadPoolExecutor(max_workers=2) as executor:
            future = executor.submit(extract_info)
            progress_future = executor.submit(show_progress)
            
            try:
                result = future.result(timeout=timeout)
                extract_info.done = True  # Stop progress indicator
                print("\r‚úÖ Information extracted successfully!          ")
                return result
            except TimeoutError:
                extract_info.done = True
                print(f"\r‚ùå Information extraction timed out after {timeout} seconds")
                return None
            except Exception as e:
                extract_info.done = True
                print(f"\r‚ùå Error in information extraction: {e}")
                return None
    
    def download_media(self, url, quality="best", audio_only=False, output_format=None, custom_format=None, interactive=False, add_metadata=False, add_thumbnail=False, custom_filename=None):
        """Download media with enhanced options and smart URL handling"""
        try:
            # Setup signal handlers
            self.setup_signal_handlers()
            
            # Handle special platforms
            platform = self.detect_platform(url)
            
            # Show beautiful download start panel
            if RICH_AVAILABLE and self.console:
                download_info = f"""
[bold cyan]Platform:[/bold cyan] [yellow]{platform.upper()}[/yellow]
[bold cyan]Quality:[/bold cyan] [green]{quality}[/green]
[bold cyan]Mode:[/bold cyan] [magenta]{'Audio Only' if audio_only else 'Video + Audio'}[/magenta]
[bold cyan]Format:[/bold cyan] [blue]{output_format if output_format else 'Auto'}[/blue]
"""
                self.print_panel(download_info, title="üöÄ Starting Download", border_style="green")
            else:
                print(f"üåê Detected platform: {platform.upper()}")
            
            # For Spotify/Apple Music, use enhanced handlers first
            if platform == 'spotify':
                return self.search_and_download_spotify_track(url)
            elif platform == 'apple_music':
                return self.search_and_download_apple_music_track(url, interactive=interactive)
            
            # Check if URL might be a playlist
            if self.is_playlist_url(url):
                print("üîç Playlist detected in URL!")
                
                if interactive:
                    choice_options = [
                        "Download as playlist (all videos/songs)",
                        "Download single item only",
                        "Show playlist contents first"
                    ]
                    
                    choice = self.prompt_user_choice(
                        "This appears to be a playlist URL. What would you like to do?",
                        choice_options,
                        default="Show playlist contents first"
                    )
                    
                    if choice == "Download as playlist (all videos/songs)":
                        return self.download_playlist(url, quality, audio_only, output_format, custom_format, interactive=interactive)
                    elif choice == "Show playlist contents first":
                        playlist_info = self.show_playlist_contents(url)
                        if playlist_info:
                            # Ask again after showing contents
                            download_choice = self.prompt_user_choice(
                                "Now what would you like to do?",
                                ["Download entire playlist", "Download single item only", "Cancel"],
                                default="Download entire playlist"
                            )
                            
                            if download_choice == "Download entire playlist":
                                return self.download_playlist(url, quality, audio_only, output_format, custom_format, interactive=interactive)
                            elif download_choice == "Cancel":
                                print("‚ùå Download cancelled by user")
                                return None
                            # else: continue with single download
                    # else: continue with single download (clean URL to remove playlist params)
                    
                    # Clean URL for single item download
                    url = self.clean_url(url)
                    print(f"üéØ Downloading single item from: {url}")
                else:
                    # Non-interactive mode: clean URL and download single item
                    print("‚ÑπÔ∏è  Non-interactive mode: downloading single item only")
                    url = self.clean_url(url)
                    print(f"üéØ Downloading: {url}")
            
            # Platform-specific handling already done above for spotify/apple_music
            
            # Interactive format selection
            if interactive and not custom_format:
                quality, audio_only, output_format, custom_format = self.prompt_format_selection(url)
            
            # Configure yt-dlp options
            ydl_opts = self.default_ydl_opts.copy()
            
            # Set custom filename if provided
            if custom_filename:
                # Clean filename to remove invalid characters
                safe_filename = custom_filename.replace('/', '-').replace('\\', '-').replace(':', '-')
                ydl_opts['outtmpl'] = str(self.output_dir / f'{safe_filename}.%(ext)s')
            
            # Set format selector
            if custom_format:
                ydl_opts['format'] = custom_format
            else:
                ydl_opts['format'] = self._get_format_selector(quality, audio_only)
            
            # Set output format and post-processors with enhanced quality settings
            if output_format:
                if audio_only and output_format.lower() in ['mp3', 'wav', 'flac', 'aac', 'm4a', 'opus']:
                    # Enhanced quality settings for different formats
                    quality_settings = {
                        'mp3': '320',      # 320kbps for MP3
                        'aac': '256',      # 256kbps for AAC
                        'm4a': '256',      # 256kbps for M4A
                        'opus': '256',     # 256kbps for Opus
                        'flac': '0',       # Lossless for FLAC
                        'wav': '0',        # Lossless for WAV
                    }
                    
                    ydl_opts['postprocessors'] = [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': output_format.lower(),
                        'preferredquality': quality_settings.get(output_format.lower(), '320'),
                        'nopostoverwrites': False,
                    }]
                elif not audio_only and output_format.lower() in ['mp4', 'mkv', 'avi', 'webm', 'mov']:
                    ydl_opts['merge_output_format'] = output_format.lower()
            
            # Enhanced thumbnail and metadata support with artist cover art preference
            if add_thumbnail:
                ydl_opts['writethumbnail'] = True
                
                # Add thumbnail embedding for audio files with enhanced options
                if audio_only:
                    if 'postprocessors' not in ydl_opts:
                        ydl_opts['postprocessors'] = []
                    
                    # Enhanced thumbnail embedding with better quality settings
                    ydl_opts['postprocessors'].append({
                        'key': 'EmbedThumbnail',
                        'already_have_thumbnail': False,
                    })
                    
                    # Add comprehensive metadata processor
                    ydl_opts['postprocessors'].append({
                        'key': 'FFmpegMetadata',
                        'add_metadata': True,
                        'add_chapters': True,
                        'add_infojson': False,  # Don't embed the entire JSON
                    })
            
            # Enhanced metadata support even without thumbnail
            elif add_metadata and audio_only:
                if 'postprocessors' not in ydl_opts:
                    ydl_opts['postprocessors'] = []
                ydl_opts['postprocessors'].append({
                    'key': 'FFmpegMetadata',
                    'add_metadata': True,
                    'add_chapters': True,
                })
            
            # Always enable basic metadata and thumbnails for audio files if not specified
            elif audio_only:
                ydl_opts['writethumbnail'] = True
                if 'postprocessors' not in ydl_opts:
                    ydl_opts['postprocessors'] = []
                ydl_opts['postprocessors'].extend([{
                    'key': 'EmbedThumbnail',
                    'already_have_thumbnail': False,
                }, {
                    'key': 'FFmpegMetadata',
                    'add_metadata': True,
                    'add_chapters': True,
                }])
            
            # Add progress hook
            ydl_opts['progress_hooks'] = [self._progress_hook]
            
            # Download
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                print(f"üé¨ Starting download: {url}")
                
                # Get info first
                info = ydl.extract_info(url, download=False)
                if info:
                    print(f"\nüì∫ MEDIA INFO:")
                    print(f"üì∫ Title: {info.get('title', 'Unknown')}")
                    print(f"‚è±Ô∏è  Duration: {self._format_duration(info.get('duration', 0))}")
                    print(f"üë§ Uploader: {info.get('uploader', 'Unknown')}")
                    
                    # Show additional info if available
                    if info.get('view_count'):
                        print(f"üëÄ Views: {info.get('view_count'):,}")
                    if info.get('upload_date'):
                        print(f"üìÖ Upload Date: {info.get('upload_date')}")
                    if info.get('like_count'):
                        print(f"üëç Likes: {info.get('like_count'):,}")
                    
                    # Show download settings
                    print(f"\n‚öôÔ∏è  DOWNLOAD SETTINGS:")
                    print(f"üéØ Quality: {quality}")
                    print(f"üéµ Audio only: {'Yes' if audio_only else 'No'}")
                    if output_format:
                        print(f"üìÑ Output format: {output_format.upper()}")
                    if custom_format:
                        print(f"üîß Custom format: {custom_format}")
                
                # Start download
                if RICH_AVAILABLE and self.console:
                    self.console.print("\n[bold green]üöÄ Starting download...[/bold green]")
                else:
                    print("\nüöÄ Starting download...")
                
                ydl.download([url])
                
                if not self.cancelled:
                    # Show beautiful completion message
                    if RICH_AVAILABLE and self.console:
                        completion_msg = """
[bold green]‚ú® Download completed successfully! ‚ú®[/bold green]

[cyan]üéâ Your media is ready![/cyan]
"""
                        self.print_panel(completion_msg, title="üéä SUCCESS", border_style="green")
                    else:
                        print("\n‚úÖ Download completed successfully!")
                    
                    # Show downloaded file info
                    if info:
                        title = info.get('title', 'Unknown')
                        artist = info.get('artist') or info.get('uploader', 'Unknown')
                        ext = 'mp3' if audio_only else 'mp4'
                        if output_format:
                            ext = output_format.lower()
                        
                        expected_filename = f"{artist} - {title}.{ext}"
                        downloaded_file_path = self.output_dir / expected_filename
                        
                        print(f"üìÅ File saved as: {expected_filename}")
                        print(f"üìÇ Location: {self.output_dir}")
                        
                        # Enhanced post-processing for audio files
                        if audio_only and downloaded_file_path.exists():
                            print("\nüé® Applying enhanced post-processing...")
                            
                            # Fetch and embed album art from Spotify/Apple Music
                            if platform not in ['spotify', 'apple_music']:  # Only if not from streaming service
                                self._enhance_audio_with_metadata(
                                    str(downloaded_file_path),
                                    title,
                                    artist,
                                    fetch_from_streaming=True
                                )
                            
                            # Convert to true lossless if FLAC or WAV requested
                            if output_format and output_format.lower() in ['flac', 'wav']:
                                print(f"\nüîÑ Converting to true {output_format.upper()} format...")
                                converted_path = self._convert_to_true_lossless(
                                    str(downloaded_file_path),
                                    target_format=output_format.lower()
                                )
                                if converted_path != str(downloaded_file_path):
                                    downloaded_file_path = Path(converted_path)
                                    print(f"‚úÖ Converted to: {downloaded_file_path.name}")
                    
                    # Cleanup intermediate files (thumbnails, json, etc.)
                    self._cleanup_intermediate_files(info, audio_only, output_format)
                
                return info
                
        except KeyboardInterrupt:
            print("\n‚ùå Download cancelled by user")
            return None
        except Exception as e:
            error_msg = str(e)
            print(f"\n‚ùå Error downloading media: {error_msg}")
            
            # Print full traceback for debugging
            import traceback
            print(f"\nüîç Full error details:")
            traceback.print_exc()
            
            # Try to provide helpful error messages
            if "video unavailable" in error_msg.lower():
                print("üí° Tip: The video might be private, deleted, or region-restricted")
            elif "format not available" in error_msg.lower():
                print("üí° Tip: Try a different quality setting or use --show-formats to see available options")
            elif "ffmpeg" in error_msg.lower() or "avconv" in error_msg.lower():
                print("üí° Tip: FFmpeg might not be installed or not in PATH. Install it with:")
                print("   macOS: brew install ffmpeg")
                print("   Ubuntu/Debian: sudo apt-get install ffmpeg")
                print("   Windows: Download from https://ffmpeg.org/download.html")
            elif not error_msg or error_msg.strip() == "":
                print("üí° Tip: An unknown error occurred. The video might be unavailable or have restricted access")
            
            # Don't fail completely, return None to continue with other tracks
            return None
    
    def download_batch_optimized(self, urls, quality="best", audio_only=False, output_format=None, max_concurrent=3):
        """
        Optimized batch download with parallel processing and smart queue management
        
        Args:
            urls: List of URLs to download
            quality: Quality setting for all downloads
            audio_only: Download audio only
            output_format: Output format (mp3, flac, opus, m4a, etc.)
            max_concurrent: Maximum concurrent downloads (default: 3)
        """
        if not urls:
            print("‚ùå No URLs provided for batch download")
            return []
        
        print(f"üöÄ Starting optimized batch download of {len(urls)} items")
        print(f"‚öôÔ∏è  Settings: Quality={quality}, Audio Only={audio_only}, Format={output_format or 'default'}")
        print(f"üîÑ Max concurrent downloads: {max_concurrent}")
        
        successful_downloads = []
        failed_downloads = []
        
        def download_single_threaded(url_info):
            """Download a single URL in a thread"""
            url, index = url_info
            try:
                print(f"\nüì• [{index+1}/{len(urls)}] Starting: {url}")
                
                # Create thread-specific downloader to avoid conflicts
                thread_downloader = UltimateMediaDownloader(self.output_dir)
                
                # Use enhanced settings for better performance
                result = thread_downloader.download_media(
                    url=url,
                    quality=quality,
                    audio_only=audio_only,
                    output_format=output_format,
                    add_metadata=True,
                    add_thumbnail=True
                )
                
                if result:
                    successful_downloads.append((url, result))
                    print(f"‚úÖ [{index+1}/{len(urls)}] Completed: {result.get('title', 'Unknown')}")
                else:
                    failed_downloads.append(url)
                    print(f"‚ùå [{index+1}/{len(urls)}] Failed: {url}")
                    
            except Exception as e:
                failed_downloads.append(url)
                print(f"‚ùå [{index+1}/{len(urls)}] Error: {e}")
        
        # Use ThreadPoolExecutor for controlled parallel downloads
        try:
            with ThreadPoolExecutor(max_workers=max_concurrent) as executor:
                # Submit all download tasks
                url_with_index = [(url, i) for i, url in enumerate(urls)]
                futures = [executor.submit(download_single_threaded, url_info) for url_info in url_with_index]
                
                # Wait for all downloads to complete
                for future in futures:
                    try:
                        future.result(timeout=3600)  # 1 hour timeout per download
                    except TimeoutError:
                        print("‚ö†Ô∏è  Download timed out after 1 hour")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Thread execution error: {e}")
        
        except KeyboardInterrupt:
            print("\n‚ùå Batch download cancelled by user")
        
        # Print summary
        print(f"\nüìä BATCH DOWNLOAD SUMMARY:")
        print(f"‚úÖ Successful: {len(successful_downloads)}")
        print(f"‚ùå Failed: {len(failed_downloads)}")
        print(f"üìà Success rate: {len(successful_downloads)/len(urls)*100:.1f}%")
        
        if failed_downloads:
            print(f"\n‚ùå Failed URLs:")
            for i, url in enumerate(failed_downloads, 1):
                print(f"  {i}. {url}")
        
        return successful_downloads
    
    def show_playlist_contents(self, url, max_display=20):
        """Display playlist contents for user review"""
        try:
            print("üîç Extracting playlist information...")
            
            ydl_opts = self.default_ydl_opts.copy()
            ydl_opts.update({
                'quiet': True,
                'extract_flat': True,  # Fast extraction for listing
                'noplaylist': False,
            })
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if not info or not info.get('entries'):
                    print("‚ùå No playlist found or playlist is empty")
                    return None
                
                entries = [entry for entry in info['entries'] if entry]  # Filter out None entries
                total_videos = len(entries)
                
                print("\n" + "="*80)
                print(f"üìã PLAYLIST: {info.get('title', 'Unknown Playlist')}")
                print("="*80)
                print(f"üë§ Creator: {info.get('uploader', 'Unknown')}")
                print(f"üìä Total videos: {total_videos}")
                print(f"üìÖ Playlist URL: {info.get('webpage_url', url)}")
                
                if info.get('description'):
                    desc = info['description'][:150] + '...' if len(info['description']) > 150 else info['description']
                    print(f"üìÑ Description: {desc}")
                
                print("\nüéµ PLAYLIST CONTENTS:")
                print("-" * 80)
                
                # Display videos
                display_count = min(max_display, total_videos)
                for i, entry in enumerate(entries[:display_count], 1):
                    if entry:
                        title = entry.get('title', 'Unknown Title')
                        duration = self._format_duration(entry.get('duration', 0))
                        uploader = entry.get('uploader', 'Unknown')
                        
                        # Truncate long titles
                        if len(title) > 50:
                            title = title[:47] + "..."
                        
                        print(f"{i:3d}. {title:<50} | {duration:>8} | {uploader}")
                
                if total_videos > max_display:
                    print(f"     ... and {total_videos - max_display} more videos")
                
                print("-" * 80)
                return info
                
        except Exception as e:
            print(f"‚ùå Error extracting playlist: {e}")
            return None
    
    def download_playlist(self, url, quality="best", audio_only=False, output_format=None, custom_format=None, max_downloads=None, start_index=1, interactive=True):
        """Download playlist with enhanced options and user interaction"""
        try:
            platform = self.detect_platform(url)
            if RICH_AVAILABLE and self.console:
                self.console.print(f"[bold cyan]‚Üí[/bold cyan] Detected platform: [cyan]{platform.upper()}[/cyan]")
            else:
                print(f"‚Üí Detected platform: {platform.upper()}")
            
            # Show playlist contents first
            playlist_info = self.show_playlist_contents(url)
            if not playlist_info:
                return
            
            total_videos = len([e for e in playlist_info.get('entries', []) if e])
            
            if interactive:
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"\n[bold white]DOWNLOAD OPTIONS[/bold white]")
                else:
                    print(f"\nDOWNLOAD OPTIONS")
                print("=" * 50)
                
                # Ask how many to download
                download_options = [
                    f"Download all {total_videos} videos",
                    "Download specific range",
                    "Download first N videos",
                    "Cancel download"
                ]
                
                download_choice = self.prompt_user_choice(
                    "What would you like to download?",
                    download_options,
                    default=download_options[0]
                )
                
                if download_choice == "Cancel download":
                    print("‚ùå Download cancelled by user")
                    return
                
                elif download_choice == "Download specific range":
                    while True:
                        try:
                            start_input = input(f"Start from video number (1-{total_videos}): ").strip()
                            start_index = int(start_input) if start_input else 1
                            
                            end_input = input(f"End at video number ({start_index}-{total_videos}): ").strip()
                            end_index = int(end_input) if end_input else total_videos
                            
                            if 1 <= start_index <= end_index <= total_videos:
                                max_downloads = end_index - start_index + 1
                                break
                            else:
                                print("Invalid range. Please try again.")
                        except ValueError:
                            print("Please enter valid numbers.")
                
                elif download_choice == "Download first N videos":
                    while True:
                        try:
                            max_input = input(f"How many videos to download (1-{total_videos}): ").strip()
                            max_downloads = int(max_input) if max_input else total_videos
                            if 1 <= max_downloads <= total_videos:
                                start_index = 1  # Reset to 1 for "first N"
                                break
                            else:
                                print(f"Please enter a number between 1 and {total_videos}")
                        except ValueError:
                            print("Please enter a valid number.")
                
                # Ask for quality and format selection
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"\n[bold white]QUALITY & FORMAT OPTIONS[/bold white]")
                    self.console.print("=" * 50)
                else:
                    print(f"\nQUALITY & FORMAT OPTIONS")
                    print("=" * 50)
                
                # Ask if audio only or video
                media_type_options = ["Audio Only (Music)", "Video + Audio", "Video Only"]
                media_type_choice = self.prompt_user_choice(
                    "What type of media?",
                    media_type_options,
                    default="Audio Only (Music)"
                )
                
                audio_only = (media_type_choice == "Audio Only (Music)")
                
                if audio_only:
                    # Audio quality and format selection
                    format_options = [
                        "FLAC (Lossless, Largest file)",
                        "WAV (Lossless, Uncompressed)",
                        "OPUS (High quality, Smaller)",
                        "MP3 320kbps (Standard)",
                        "M4A/AAC (Apple format)",
                    ]
                    format_choice = self.prompt_user_choice(
                        "Select audio format:",
                        format_options,
                        default="FLAC (Lossless, Largest file)"
                    )
                    
                    format_map = {
                        "FLAC (Lossless, Largest file)": "flac",
                        "WAV (Lossless, Uncompressed)": "wav",
                        "OPUS (High quality, Smaller)": "opus",
                        "MP3 320kbps (Standard)": "mp3",
                        "M4A/AAC (Apple format)": "m4a",
                    }
                    output_format = format_map[format_choice]
                    quality = "best"  # Always use best quality for audio
                    
                else:
                    # Video quality selection
                    quality_options = [
                        "Best (4K/2160p if available)",
                        "1440p (2K)",
                        "1080p (Full HD)",
                        "720p (HD)",
                        "480p (SD)",
                        "360p (Low quality)"
                    ]
                    quality_choice = self.prompt_user_choice(
                        "Select video quality:",
                        quality_options,
                        default="1080p (Full HD)"
                    )
                    
                    quality_map = {
                        "Best (4K/2160p if available)": "best",
                        "1440p (2K)": "1440p",
                        "1080p (Full HD)": "1080p",
                        "720p (HD)": "720p",
                        "480p (SD)": "480p",
                        "360p (Low quality)": "360p"
                    }
                    quality = quality_map[quality_choice]
                    
                    # Ask for video format
                    video_format_options = ["MP4 (Compatible)", "MKV (High quality)", "WEBM (Smaller size)"]
                    video_format_choice = self.prompt_user_choice(
                        "Select video format:",
                        video_format_options,
                        default="MP4 (Compatible)"
                    )
                    
                    video_format_map = {
                        "MP4 (Compatible)": "mp4",
                        "MKV (High quality)": "mkv",
                        "WEBM (Smaller size)": "webm"
                    }
                    output_format = video_format_map[video_format_choice]
                
                # Confirm download
                actual_downloads = max_downloads if max_downloads else total_videos
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"\n[bold green]‚Üí[/bold green] Ready to download [cyan]{actual_downloads}[/cyan] items starting from [cyan]#{start_index}[/cyan]")
                    self.console.print(f"[bold white]Format:[/bold white] [cyan]{output_format.upper()}[/cyan]")
                    self.console.print(f"[bold white]Quality:[/bold white] [cyan]{'Audio Only - ' + output_format.upper() if audio_only else quality}[/cyan]")
                else:
                    print(f"\n‚Üí Ready to download {actual_downloads} items starting from #{start_index}")
                    print(f"Format: {output_format.upper()}")
                    print(f"Quality: {'Audio Only - ' + output_format.upper() if audio_only else quality}")
                
                confirm = input("Continue? (y/n): ").strip().lower()
                if confirm not in ['y', 'yes', '']:
                    if RICH_AVAILABLE and self.console:
                        self.console.print("[bold red]‚úó[/bold red] Download cancelled by user")
                    else:
                        print("‚úó Download cancelled by user")
                    return
            
            # Configure download options
            ydl_opts = self.default_ydl_opts.copy()
            ydl_opts.update({
                'outtmpl': str(self.output_dir / '%(playlist)s/%(playlist_index)03d - %(title)s.%(ext)s'),
                'noplaylist': False,
                'playliststart': start_index,
                'extract_flat': False,  # Get full info for each video
            })
            
            # Set format
            if custom_format:
                ydl_opts['format'] = custom_format
            else:
                ydl_opts['format'] = self._get_format_selector(quality, audio_only)
            
            if max_downloads:
                ydl_opts['playlistend'] = start_index + max_downloads - 1
            
            # Set output format and post-processors
            if output_format:
                if audio_only and output_format.lower() in ['mp3', 'wav', 'flac', 'aac', 'm4a', 'opus']:
                    ydl_opts['postprocessors'] = [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': output_format.lower(),
                        'preferredquality': '320' if output_format.lower() == 'mp3' else '0',
                    }]
                elif not audio_only and output_format.lower() in ['mp4', 'mkv', 'avi', 'webm', 'mov']:
                    ydl_opts['merge_output_format'] = output_format.lower()
            
            ydl_opts['progress_hooks'] = [self._progress_hook]
            
            # Track current file for metadata enhancement
            self._current_playlist_dir = str(self.output_dir / playlist_info.get('title', 'Unknown'))
            self._playlist_audio_only = audio_only
            self._playlist_format = output_format
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"\n[bold cyan]‚ñ∂[/bold cyan] Starting playlist download...", style="bold")
                else:
                    print(f"\n‚ñ∂ Starting playlist download...")
                
                actual_downloads = max_downloads if max_downloads else total_videos
                
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"[bold white]Downloading {actual_downloads} items from:[/bold white] [cyan]{playlist_info.get('title', 'Unknown')}[/cyan]")
                else:
                    print(f"Downloading {actual_downloads} items from: {playlist_info.get('title', 'Unknown')}")
                
                ydl.download([url])
                
                # Post-process: Add album art to audio files
                if audio_only and output_format in ['flac', 'mp3', 'm4a']:
                    self._add_album_art_to_playlist(self._current_playlist_dir)
                
                if RICH_AVAILABLE and self.console:
                    self.console.print(f"\n[bold green]‚úì[/bold green] Playlist download completed!", style="bold green")
                else:
                    print("\n‚úì Playlist download completed!")
                
        except KeyboardInterrupt:
            if RICH_AVAILABLE and self.console:
                self.console.print("\n[bold red]‚úó[/bold red] Download cancelled by user")
            else:
                print("\n‚úó Download cancelled by user")
        except Exception as e:
            if RICH_AVAILABLE and self.console:
                self.console.print(f"[bold red]‚úó[/bold red] Error downloading playlist: [red]{str(e)}[/red]")
            else:
                print(f"‚úó Error downloading playlist: {str(e)}")
    
    def _get_format_selector(self, quality, audio_only):
        """Get format selector string for yt-dlp with enhanced audio quality support"""
        if audio_only:
            # Prioritize high-quality audio formats: FLAC > Opus > M4A > AAC > MP3
            return ('bestaudio[acodec=flac]/bestaudio[acodec=opus]/bestaudio[acodec=m4a]/'
                   'bestaudio[acodec=aac]/bestaudio[abr>=320]/bestaudio[abr>=256]/'
                   'bestaudio[abr>=192]/bestaudio/best')
        
        quality_map = {
            'best': 'bestvideo[height<=2160]+bestaudio[acodec=flac]/bestvideo[height<=2160]+bestaudio[acodec=opus]/bestvideo+bestaudio/best',
            'worst': 'worst',
            '1080p': 'bestvideo[height<=1080]+bestaudio[acodec=flac]/bestvideo[height<=1080]+bestaudio[acodec=opus]/bestvideo[height<=1080]+bestaudio/best[height<=1080]',
            '720p': 'bestvideo[height<=720]+bestaudio[acodec=flac]/bestvideo[height<=720]+bestaudio[acodec=opus]/bestvideo[height<=720]+bestaudio/best[height<=720]',
            '480p': 'bestvideo[height<=480]+bestaudio[acodec=flac]/bestvideo[height<=480]+bestaudio[acodec=opus]/bestvideo[height<=480]+bestaudio/best[height<=480]',
            '360p': 'bestvideo[height<=360]+bestaudio[acodec=flac]/bestvideo[height<=360]+bestaudio[acodec=opus]/bestvideo[height<=360]+bestaudio/best[height<=360]',
            '1440p': 'bestvideo[height<=1440]+bestaudio[acodec=flac]/bestvideo[height<=1440]+bestaudio[acodec=opus]/bestvideo[height<=1440]+bestaudio/best[height<=1440]',
            '2160p': 'bestvideo[height<=2160]+bestaudio[acodec=flac]/bestvideo[height<=2160]+bestaudio[acodec=opus]/bestvideo[height<=2160]+bestaudio/best[height<=2160]',  # 4K
            '4k': 'bestvideo[height<=2160]+bestaudio[acodec=flac]/bestvideo[height<=2160]+bestaudio[acodec=opus]/bestvideo[height<=2160]+bestaudio/best[height<=2160]',
        }
        
        return quality_map.get(quality, 'bestvideo+bestaudio[acodec=flac]/bestvideo+bestaudio[acodec=opus]/bestvideo+bestaudio/best')
    
    def _enhance_audio_metadata(self, info_dict, output_format):
        """Enhance metadata extraction for better audio tagging"""
        enhanced_opts = {
            'writeinfojson': True,
            'writethumbnail': True,
            'writesubtitles': False,
            
            # Try to extract artist-specific thumbnails and info
            'extract_flat': False,
            'force_json': True,
            
            # Enhanced thumbnail options
            'thumbnail_format': 'jpg/png/webp',
        }
        
        # Format-specific optimizations
        if output_format and output_format.lower() in ['flac', 'wav']:
            # For lossless formats, get the highest quality thumbnail
            enhanced_opts['thumbnail_max_size'] = '1920x1920'
        elif output_format and output_format.lower() in ['mp3', 'm4a', 'aac']:
            # For compressed formats, optimize thumbnail size
            enhanced_opts['thumbnail_max_size'] = '1200x1200'
        
        return enhanced_opts
    
    def _get_artist_cover_art(self, url, info_dict=None):
        """Attempt to get proper artist cover art instead of video thumbnail"""
        try:
            # For music videos, try to extract artist/album information
            if info_dict:
                title = info_dict.get('title', '').lower()
                uploader = info_dict.get('uploader', '').lower()
                
                # Check if this looks like a music video
                music_indicators = ['official', 'music video', 'mv', 'official video', 
                                  'lyric video', 'lyrics', 'audio', 'song']
                
                if any(indicator in title for indicator in music_indicators):
                    print("üéµ Music content detected, optimizing for artist cover art...")
                    
                    # Try to extract artist and song name
                    # Common patterns: "Artist - Song", "Song by Artist", etc.
                    import re
                    
                    # Pattern 1: "Artist - Song Title"
                    match = re.search(r'^(.+?)\s*[-‚Äì]\s*(.+?)(?:\s*\([^)]*\))?(?:\s*\[.*\])?$', title)
                    if match:
                        artist, song = match.groups()
                        print(f"üéµ Detected: Artist: {artist.strip()}, Song: {song.strip()}")
                        return {'artist': artist.strip(), 'song': song.strip()}
                    
                    # Pattern 2: Try uploader as artist
                    if 'vevo' in uploader or 'records' in uploader or 'music' in uploader:
                        # Extract artist name from uploader (remove common suffixes)
                        clean_uploader = re.sub(r'\s*(vevo|records|music|official).*$', '', uploader, flags=re.I)
                        if clean_uploader:
                            print(f"üéµ Using uploader as artist: {clean_uploader}")
                            return {'artist': clean_uploader.strip(), 'song': title}
            
            return None
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error extracting artist info: {e}")
            return None
    
    def _progress_hook(self, d):
        """Enhanced progress hook for download status with better formatting and Rich support"""
        if d['status'] == 'downloading':
            if 'total_bytes' in d and d['total_bytes']:
                percent = d['downloaded_bytes'] / d['total_bytes'] * 100
                speed = d.get('speed', 0)
                eta = d.get('eta', 0)
                
                # Enhanced speed formatting
                if speed:
                    if speed > 1024 * 1024:  # MB/s
                        speed_str = f"{speed/1024/1024:.1f}MB/s"
                    else:  # KB/s
                        speed_str = f"{speed/1024:.0f}KB/s"
                else:
                    speed_str = "---KB/s"
                
                # Enhanced ETA formatting
                if eta:
                    if eta > 3600:  # Hours
                        eta_str = f"{eta//3600}h{(eta%3600)//60:02d}m"
                    elif eta > 60:  # Minutes
                        eta_str = f"{eta//60}m{eta%60:02d}s"
                    else:  # Seconds
                        eta_str = f"{eta:2.0f}s"
                else:
                    eta_str = "--:--"
                
                # Calculate downloaded size with better formatting
                downloaded_mb = d['downloaded_bytes'] / 1024 / 1024
                total_mb = d['total_bytes'] / 1024 / 1024
                
                # Create progress bar
                bar_length = 30
                filled_length = int(bar_length * percent / 100)
                
                # Create simple progress bar using plain text with ANSI colors
                bar = '‚îÅ' * filled_length + '‚ñë' * (bar_length - filled_length)
                
                # Use ANSI color codes for compatibility
                # Yellow ‚ñº, Green %, Cyan progress/sizes, Magenta speed, Blue ETA
                progress_line = (
                    f"\r\033[1;33m‚ñº\033[0m "  # Yellow ‚ñº
                    f"\033[1;32m{percent:5.1f}%\033[0m "  # Green %
                    f"[\033[36m{bar[:filled_length]}\033[0m"  # Cyan filled
                    f"\033[2;37m{bar[filled_length:]}\033[0m] "  # Dim white empty
                    f"\033[1;36m{downloaded_mb:6.1f}/{total_mb:6.1f}MB\033[0m "  # Cyan sizes
                    f"| \033[1;35m{speed_str:>10}\033[0m "  # Magenta speed
                    f"| ETA: \033[1;34m{eta_str}\033[0m"  # Blue ETA
                )
                
                print(progress_line, end="", flush=True)
            else:
                # Fallback for unknown total size
                downloaded_mb = d.get('downloaded_bytes', 0) / 1024 / 1024
                speed = d.get('speed', 0)
                speed_str = f"{speed/1024/1024:.1f}MB/s" if speed else "---KB/s"
                
                # Use ANSI colors
                progress_line = (
                    f"\r\033[1;33m‚ñº\033[0m "  # Yellow ‚ñº
                    f"Downloaded: \033[1;36m{downloaded_mb:6.1f}MB\033[0m "  # Cyan size
                    f"| \033[1;35m{speed_str:>10}\033[0m"  # Magenta speed
                )
                
                print(progress_line, end="", flush=True)
                
        elif d['status'] == 'finished':
            filename = os.path.basename(d['filename'])
            # Clear the progress line completely before printing completion
            print("\r" + " " * 120, end="\r", flush=True)
            print(f"\033[1;32m‚úì\033[0m Download complete: \033[32m{filename}\033[0m")
            
        elif d['status'] == 'error':
            error_msg = d.get('error', 'Unknown error')
            print("\r" + " " * 120, end="\r", flush=True)
            print(f"\033[1;31m‚úó\033[0m Download error: \033[31m{error_msg}\033[0m")
            
        elif d['status'] == 'processing':
            # Processing happens quickly, no need to show
            pass
    
    def _format_duration(self, seconds):
        """Format duration in human readable format"""
        if not seconds or seconds == 'Unknown':
            return "Unknown"
        
        try:
            seconds = int(seconds)
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            secs = seconds % 60
            
            if hours > 0:
                return f"{hours}h {minutes}m {secs}s"
            elif minutes > 0:
                return f"{minutes}m {secs}s"
            else:
                return f"{secs}s"
        except:
            return "Unknown"
    
    def _cleanup_intermediate_files(self, info, audio_only=False, output_format=None):
        """Clean up intermediate files (thumbnails, json, etc.) after download completes"""
        try:
            if not info:
                return
            
            title = info.get('title', 'Unknown')
            uploader = info.get('uploader', 'Unknown')
            
            # Determine the main output file extension
            main_ext = output_format.lower() if output_format else ('mp3' if audio_only else 'mp4')
            main_filename_base = f"{uploader} - {title}"
            
            # List of intermediate file extensions to clean up
            intermediate_extensions = [
                '.jpg', '.jpeg', '.png', '.webp',  # Thumbnails
                '.info.json',  # Info JSON
                '.description',  # Description files
                '.annotations.xml',  # Annotations
                '.webm', '.m4a', '.part',  # Temp video/audio files
            ]
            
            # If audio_only, also remove video files that might remain
            if audio_only:
                intermediate_extensions.extend(['.mp4', '.mkv', '.webm', '.avi', '.mov'])
            
            print("\nüßπ Cleaning up intermediate files...")
            cleaned_count = 0
            
            # Search for and remove intermediate files
            for file_path in self.output_dir.iterdir():
                if file_path.is_file():
                    file_name = file_path.name
                    file_stem = file_path.stem
                    
                    # Check if this is an intermediate file related to our download
                    for ext in intermediate_extensions:
                        if file_name.endswith(ext):
                            # Make sure it's related to this download
                            if main_filename_base in file_name or title in file_name:
                                try:
                                    file_path.unlink()
                                    cleaned_count += 1
                                    print(f"  üóëÔ∏è  Removed: {file_name}")
                                except Exception as e:
                                    print(f"  ‚ö†Ô∏è  Could not remove {file_name}: {e}")
                                break
            
            if cleaned_count > 0:
                print(f"‚úÖ Cleaned up {cleaned_count} intermediate file(s)")
            else:
                print("‚úÖ No intermediate files to clean")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Cleanup error: {e}")
    
    def check_url_support(self, url, silent=False):
        """Check if URL is supported"""
        try:
            platform = self.detect_platform(url)
            if not silent:
                print(f"üåê Detected platform: {platform.upper()}")

            # Treat Apple Music and Spotify as supported (handled via search/metadata)
            if platform in ("apple_music", "spotify"):
                if not silent:
                    print("‚úÖ URL supported via enhanced handler (YouTube search + metadata)")
                return True
            
            # Try to extract info to check if URL is supported
            with yt_dlp.YoutubeDL({'quiet': True, 'no_warnings': True}) as ydl:
                try:
                    # Try to extract basic info without downloading
                    info = ydl.extract_info(url, download=False, process=False)
                    if info:
                        extractor_name = info.get('extractor', 'Unknown')
                        print(f"‚úÖ URL supported by extractor: {extractor_name}")
                        
                        # Show basic info if available
                        if info.get('title'):
                            print(f"üì∫ Title: {info.get('title')}")
                        if info.get('uploader'):
                            print(f"üë§ Uploader: {info.get('uploader')}")
                        
                        # Show platform-specific info
                        if platform in self.platform_configs:
                            config = self.platform_configs[platform]
                            print(f"üìã Supported formats: {', '.join(config['formats'])}")
                            if 'note' in config:
                                print(f"üìù Note: {config['note']}")
                        
                        return True
                    else:
                        print("‚ùå URL not supported - no info extracted")
                        return False
                        
                except yt_dlp.DownloadError as e:
                    if "Unsupported URL" in str(e) or "No suitable extractor" in str(e):
                        print("‚ùå URL not supported by any extractor")
                        print(f"üí° Tip: Try checking if the URL is correct and accessible")
                        return False
                    else:
                        # Other errors might still mean the URL is supported
                        print(f"‚ö†Ô∏è  URL might be supported but encountered error: {e}")
                        return True
                        
        except Exception as e:
            print(f"‚ùå Error checking URL support: {e}")
            print("üí° Tip: The URL might still work, try downloading it directly")
            return False
    
    def list_supported_platforms(self):
        """List all supported platforms with details"""
        if RICH_AVAILABLE and self.console:
            # Create beautiful table with Rich
            table = Table(
                title="üåç Supported Platforms",
                box=box.ROUNDED,
                border_style="cyan",
                header_style="bold magenta"
            )
            
            table.add_column("Platform", style="bold yellow", no_wrap=True)
            table.add_column("Domains", style="cyan")
            table.add_column("Content Types", style="green")
            
            major_platforms = [
                ("üé• YouTube", "youtube.com, youtu.be", "Videos, playlists, live streams"),
                ("üéµ Spotify", "spotify.com", "Tracks, albums, playlists"),
                ("üéß SoundCloud", "soundcloud.com", "Tracks, playlists, uploads"),
                ("üçé Apple Music", "music.apple.com", "Tracks, albums"),
                ("üì∏ Instagram", "instagram.com", "Videos, reels, IGTV"),
                ("üì± TikTok", "tiktok.com", "Videos, user content"),
                ("üê¶ Twitter/X", "twitter.com, x.com", "Video tweets"),
                ("üìò Facebook", "facebook.com", "Videos, live streams"),
                ("üé¨ Vimeo", "vimeo.com", "Videos, private content"),
                ("üéÆ Twitch", "twitch.tv", "VODs, clips, streams"),
            ]
            
            for platform, domains, content in major_platforms:
                table.add_row(platform, domains, content)
            
            self.console.print(table)
            self.console.print(f"\n[bold green]üìä Total supported sites: {len(self.get_supported_sites())} platforms[/bold green]")
            self.console.print("[yellow]üí° Use --check-support <URL> to verify URL compatibility[/yellow]")
        else:
            print("\nüåç SUPPORTED PLATFORMS")
            print("=" * 60)
            
            major_platforms = [
                ("YouTube", "youtube.com, youtu.be", "Videos, playlists, live streams"),
                ("Spotify", "spotify.com", "Tracks, albums, playlists (via YouTube search)"),
                ("SoundCloud", "soundcloud.com", "Tracks, playlists, user uploads"),
                ("Apple Music", "music.apple.com", "Tracks, albums (via YouTube search)"),
                ("Instagram", "instagram.com", "Videos, reels, IGTV"),
                ("TikTok", "tiktok.com", "Videos, user uploads"),
                ("Twitter/X", "twitter.com, x.com", "Videos from tweets"),
                ("Facebook", "facebook.com", "Videos, live streams"),
                ("Vimeo", "vimeo.com", "Videos, private videos"),
                ("Twitch", "twitch.tv", "VODs, clips, live streams"),
            ]
            
            for name, domains, content in major_platforms:
                print(f"üé¨ {name:12} | {domains:25} | {content}")
            
            print(f"\nüìä Total supported sites: {len(self.get_supported_sites())} platforms")
            print("üí° Use --check-support <URL> to verify if a specific URL is supported")

def interactive_mode():
    """Interactive mode with modern UI and professional design"""
    downloader = UltimateMediaDownloader()
    ui = ModernUI()
    
    # Show welcome screen
    ui.show_welcome_banner()
    time.sleep(1)  # Brief pause for impact
    
    # Show interactive mode banner
    ui.show_interactive_banner()
    
    while True:
        try:
            # Get user input with styled prompt
            url = ui.prompt_input("Enter media URL or command", default=None)
            
            if not url:
                continue
            
            url = url.strip()
            
            # Handle commands
            if url.lower() in ['quit', 'exit', 'q']:
                if ui.console:
                    ui.console.print("\n[bold cyan]üëã Thank you for using Ultimate Downloader![/bold cyan]\n")
                else:
                    print("\nüëã Thank you for using Ultimate Downloader!\n")
                break
                
            elif url.lower() in ['help', 'h']:
                show_help_menu(ui)
                continue
                
            elif url.lower() in ['platforms', 'p']:
                downloader.list_supported_platforms()
                continue
                
            elif url.lower() in ['clear', 'cls']:
                ui.show_welcome_banner()
                ui.show_interactive_banner()
                continue
            
            # Validate URL
            if not url.startswith(('http://', 'https://')):
                ui.error_message("Invalid URL. Please enter a valid URL starting with 'http://' or 'https://'")
                continue
            
            # Check URL support with spinner
            spinner = ui.show_spinner("Analyzing URL...")
            if spinner:
                spinner.start()
            
            supported = downloader.check_url_support(url, silent=True)
            
            if spinner:
                spinner.stop()
            
            if not supported:
                ui.error_message("URL is not supported or invalid")
                continue
            
            # Start download with progress indication
            ui.info_message(f"Starting download from: {url[:60]}...")
            result = downloader.download_media(url, interactive=True)
            
            if result:
                ui.success_message("Download completed successfully!")
            else:
                ui.warning_message("Download was cancelled or failed")
            
            # Ask to continue
            if ui.console and RICH_AVAILABLE:
                another = Prompt.ask("\n[bold yellow]üì•[/bold yellow] Download another file?", 
                                   choices=["y", "n"], default="y")
            else:
                another = input("\nüì• Download another file? (y/n): ").strip().lower()
            
            if another in ['n', 'no']:
                if ui.console:
                    ui.console.print("\n[bold cyan]üëã Thanks for using Ultimate Downloader![/bold cyan]\n")
                else:
                    print("\nüëã Thanks for using Ultimate Downloader!\n")
                break
            
            # Clear for next iteration
            ui.show_welcome_banner()
            ui.show_interactive_banner()
                
        except KeyboardInterrupt:
            if ui.console:
                ui.console.print("\n\n[bold yellow]‚ö†[/bold yellow] Interrupted by user\n")
                ui.console.print("[bold cyan]üëã Goodbye![/bold cyan]\n")
            else:
                print("\n\n‚ö† Interrupted by user")
                print("üëã Goodbye!\n")
            break
        except Exception as e:
            ui.error_message(f"An error occurred: {str(e)}")
            ui.warning_message("Please try again with a different URL")


def show_help_menu(ui):
    """Display help menu with modern styling"""
    if ui.console and RICH_AVAILABLE:
        help_table = Table(title="[bold cyan]üìö COMMAND REFERENCE[/bold cyan]", 
                          box=box.ROUNDED, border_style="cyan", show_header=True)
        
        help_table.add_column("Command", style="yellow", justify="left")
        help_table.add_column("Aliases", style="dim", justify="left")
        help_table.add_column("Description", style="white", justify="left")
        
        help_table.add_row("help", "h", "Show this help menu")
        help_table.add_row("platforms", "p", "List all supported platforms")
        help_table.add_row("clear", "cls", "Clear the screen")
        help_table.add_row("quit", "exit, q", "Exit the application")
        help_table.add_row("[URL]", "-", "Paste any media URL to download")
        
        ui.console.print()
        ui.console.print(help_table)
        ui.console.print()
    else:
        print("\n" + "=" * 70)
        print("üìö COMMAND REFERENCE")
        print("=" * 70)
        print("  help, h          - Show this help menu")
        print("  platforms, p     - List all supported platforms")
        print("  clear, cls       - Clear the screen")
        print("  quit, exit, q    - Exit the application")
        print("  [URL]            - Paste any media URL to download")
        print("=" * 70 + "\n")


def create_banner():
    """Create a beautiful banner using Rich"""
    ui = ModernUI()
    
    if RICH_AVAILABLE and ui.console:
        # Create feature table
        feature_grid = Table.grid(padding=(0, 2))
        feature_grid.add_column(justify="center", style="cyan")
        feature_grid.add_column(justify="center", style="magenta")
        feature_grid.add_column(justify="center", style="green")
        feature_grid.add_column(justify="center", style="yellow")
        
        feature_grid.add_row("‚ñ∂ Videos", "‚ô™ Music", "üì± Social", "‚ö° Fast")
        
        panel = Panel(
            Align.center(feature_grid),
            title="[bold white]üé¨ ULTIMATE MEDIA DOWNLOADER[/bold white]",
            subtitle="[dim]Professional Edition[/dim]",
            border_style="bright_cyan",
            box=box.DOUBLE,
            padding=(1, 2)
        )
        
        ui.console.print(panel)
    else:
        print("=" * 70)
        print("üé¨ ULTIMATE MEDIA DOWNLOADER")
        print("=" * 70)


def main():
    parser = argparse.ArgumentParser(
        description=f"{Icons.get('video')} Ultimate Multi-Platform Media Downloader\n\nA powerful, feature-rich downloader supporting 1000+ platforms including YouTube, Spotify, Instagram, TikTok, SoundCloud, Apple Music, and more!",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
{'‚ïê'*79}
{Icons.get('book')} USAGE EXAMPLES
{'‚ïê'*79}

{Icons.get('target')} BASIC USAGE:
  ‚Ä¢ Interactive Mode (Recommended for Beginners):
    python ultimate_downloader.py

  ‚Ä¢ Download Single Video/Audio:
    python ultimate_downloader.py "https://www.youtube.com/watch?v=VIDEO_ID"

  ‚Ä¢ Get Media Information:
    python ultimate_downloader.py "URL" --info --show-formats

{Icons.get('audio')} AUDIO DOWNLOADS:
  ‚Ä¢ High-Quality MP3 (320kbps):
    python ultimate_downloader.py "URL" --audio-only --format mp3

  ‚Ä¢ Lossless FLAC Audio:
    python ultimate_downloader.py "URL" --audio-only --format flac

  ‚Ä¢ Download Spotify Track (via YouTube Search):
    python ultimate_downloader.py "https://open.spotify.com/track/TRACK_ID" \\
        --audio-only --format mp3

{Icons.get('video')} VIDEO DOWNLOADS:
  ‚Ä¢ Specific Quality:
    python ultimate_downloader.py "URL" --quality 1080p

  ‚Ä¢ Best Available Quality:
    python ultimate_downloader.py "URL" --quality best --format mp4

  ‚Ä¢ Custom Format (Advanced):
    python ultimate_downloader.py "URL" \\
        --custom-format "bestvideo[height<=720]+bestaudio[ext=m4a]"

{Icons.get('playlist')} PLAYLIST DOWNLOADS:
  ‚Ä¢ Interactive Playlist Download:
    python ultimate_downloader.py "PLAYLIST_URL" --playlist

  ‚Ä¢ Download First 10 Videos (Non-Interactive):
    python ultimate_downloader.py "PLAYLIST_URL" --playlist \\
        --max-downloads 10 --no-interactive

  ‚Ä¢ Download Specific Range:
    python ultimate_downloader.py "PLAYLIST_URL" --playlist \\
        --start-index 5 --max-downloads 15

{Icons.get('package')} BATCH DOWNLOADS:
  ‚Ä¢ Download Multiple URLs from File:
    python ultimate_downloader.py --batch-file urls.txt --audio-only

  ‚Ä¢ Optimized Parallel Batch Download:
    python ultimate_downloader.py --batch-file urls.txt \\
        --optimized-batch --max-concurrent 5

{Icons.get('art')} ADVANCED FEATURES:
  ‚Ä¢ Embed Metadata & Thumbnails:
    python ultimate_downloader.py "URL" --audio-only --format mp3 \\
        --embed-metadata --embed-thumbnail

  ‚Ä¢ Download with Custom Output Directory:
    python ultimate_downloader.py "URL" --output /path/to/downloads

{'‚ïê'*79}
{Icons.get('world')} SUPPORTED PLATFORMS
{'‚ïê'*79}

  {Icons.get('completed')} YouTube (Videos, Playlists, Live Streams)
  {Icons.get('completed')} Spotify (Tracks, Albums, Playlists - via YouTube search)
  {Icons.get('completed')} Apple Music (Tracks, Albums - via YouTube search)
  {Icons.get('completed')} SoundCloud (Tracks, Playlists, User Uploads)
  {Icons.get('completed')} Instagram (Videos, Reels, IGTV)
  {Icons.get('completed')} TikTok (Videos, User Content)
  {Icons.get('completed')} Twitter/X (Videos from Tweets)
  {Icons.get('completed')} Facebook (Videos, Live Streams)
  {Icons.get('completed')} Vimeo (Videos, Private Content)
  {Icons.get('completed')} Twitch (VODs, Clips, Live Streams)
  {Icons.get('completed')} And 1000+ more platforms!

  Use --list-platforms to see all supported sites
  Use --check-support <URL> to verify URL compatibility

{'‚ïê'*79}
{Icons.get('tip')} TIPS & BEST PRACTICES
{'‚ïê'*79}

  ‚Ä¢ For best audio quality, use: --audio-only --format flac
  ‚Ä¢ For universal compatibility, use: --format mp4 (video) or --format mp3 (audio)
  ‚Ä¢ Use interactive mode for guided downloading experience
  ‚Ä¢ Batch downloads support parallel processing with --optimized-batch
  ‚Ä¢ Always check available formats with --show-formats before downloading

{'‚ïê'*79}
{Icons.get('book')} For more information, visit: https://github.com/yt-dlp/yt-dlp
Report issues: Create an issue on the GitHub repository
{'‚ïê'*79}
        """
    )
    
    parser.add_argument('url', nargs='?', help='Media URL to download (if not provided, starts interactive mode)')
    parser.add_argument('-q', '--quality', default='best',
                       choices=['best', 'worst', '4k', '2160p', '1440p', '1080p', '720p', '480p', '360p'],
                       help='Video quality (default: best)')
    parser.add_argument('-a', '--audio-only', action='store_true',
                       help='Download audio only')
    parser.add_argument('-f', '--format', help='Output format (mp4, mp3, mkv, wav, flac, etc.)')
    parser.add_argument('-o', '--output', default='downloads',
                       help='Output directory (default: downloads)')
    parser.add_argument('-p', '--playlist', action='store_true',
                       help='Download playlist (with interactive options by default)')
    parser.add_argument('-m', '--max-downloads', type=int,
                       help='Maximum number of videos to download from playlist')
    parser.add_argument('-s', '--start-index', type=int, default=1,
                       help='Start index for playlist download (default: 1)')
    parser.add_argument('-i', '--info', action='store_true',
                       help='Show media info without downloading')
    parser.add_argument('--show-formats', action='store_true',
                       help='Show all available formats and qualities')
    parser.add_argument('--custom-format', help='Custom format selector for advanced users')
    parser.add_argument('--timeout', type=int, default=60,
                       help='Timeout for operations in seconds (default: 60)')
    parser.add_argument('--check-support', action='store_true',
                       help='Check if URL is supported')
    parser.add_argument('--list-platforms', action='store_true',
                       help='List all supported platforms')
    parser.add_argument('--interactive', action='store_true',
                       help='Force interactive mode even when URL is provided')
    parser.add_argument('--no-interactive', action='store_true',
                       help='Disable interactive prompts (use provided args only)')
    
    # Enhanced audio quality options
    parser.add_argument('--audio-format', 
                       choices=['mp3', 'flac', 'opus', 'm4a', 'aac', 'wav'],
                       help='Audio format (auto-selects best quality for format)')
    parser.add_argument('--audio-quality', 
                       choices=['best', 'high', 'medium', 'low'],
                       default='best',
                       help='Audio quality level (default: best)')
    
    # Performance and metadata options
    parser.add_argument('--max-concurrent', type=int, default=3,
                       help='Maximum concurrent downloads for batch operations (default: 3)')
    parser.add_argument('--embed-metadata', action='store_true',
                       help='Embed metadata and cover art in audio files')
    parser.add_argument('--embed-thumbnail', action='store_true',
                       help='Embed thumbnail/cover art in audio files')
    parser.add_argument('--prefer-artist-art', action='store_true',
                       help='Try to get artist cover art instead of video thumbnail')
    
    # Batch download options
    parser.add_argument('--batch-file', 
                       help='File containing URLs to download (one per line)')
    parser.add_argument('--optimized-batch', action='store_true',
                       help='Use optimized parallel batch downloading')
    
    args = parser.parse_args()
    
    # Create downloader instance
    downloader = UltimateMediaDownloader(args.output)
    ui = ModernUI()
    
    # Show beautiful welcome banner only in interactive mode
    # For command-line mode, keep it minimal
    
    # List platforms
    if args.list_platforms:
        downloader.list_supported_platforms()
        return
    
    # Start interactive mode if no URL provided or explicitly requested
    if not args.url or args.interactive:
        if not args.url:
            interactive_mode()
            return
        # If URL provided with --interactive, we'll use interactive mode for the URL
    
    downloader.print_rich(f"{Icons.get('folder')} Output directory: [bold cyan]{downloader.output_dir}[/bold cyan]")
    downloader.print_rich(f"{Icons.get('link')} URL: [bold blue]{args.url}[/bold blue]")
    downloader.console.print("") if downloader.console else print("")
    
    # Check URL support
    if args.check_support:
        downloader.check_url_support(args.url)
        return
    
    # Get media information
    if args.info or args.show_formats:
        downloader.print_rich(Messages.searching("Gathering media information..."))
        info = downloader.get_video_info(args.url, timeout=args.timeout)
        
        if info:
            if downloader.console:
                downloader.console.print("")
            else:
                print("")
            downloader.print_panel(
                f"[bold]{Icons.get('video')} MEDIA INFORMATION[/bold]",
                border_style="cyan"
            )
            
            details = {
                'Title': info.get('title', 'Unknown'),
                'Duration': downloader._format_duration(info.get('duration', 0)),
                'Uploader': info.get('uploader', 'Unknown'),
                'Platform': downloader.detect_platform(args.url).upper(),
                'Views': f"{info.get('view_count', 0):,}" if info.get('view_count') else 'Unknown',
                'Upload Date': info.get('upload_date', 'Unknown'),
                'Likes': f"{info.get('like_count', 0):,}" if info.get('like_count') else 'Unknown',
                'Description': (info.get('description', '')[:100] + '...') if info.get('description') else 'No description',
                'URL': info.get('webpage_url', args.url),
            }
            
            for key, value in details.items():
                print(f"{key:15}: {value}")
            
            # Show available formats if requested
            if args.show_formats:
                downloader.display_available_qualities(info)
        
        if args.info:  # If only info was requested, don't download
            return
    
    # Determine if we should use interactive mode
    use_interactive = args.interactive and not args.no_interactive
    
    # Download playlist
    if args.playlist:
        downloader.download_playlist(
            args.url, 
            args.quality, 
            args.audio_only, 
            args.format,
            args.custom_format,
            args.max_downloads,
            args.start_index,
            interactive=use_interactive
        )
        return
    
    # Handle batch file download
    if args.batch_file:
        try:
            with open(args.batch_file, 'r') as f:
                urls = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            
            if not urls:
                downloader.print_rich(Messages.error("No valid URLs found in batch file"))
                return
            
            downloader.print_rich(Messages.info(f"Found {len(urls)} URLs in batch file"))
            
            # Determine output format from args
            output_format = args.format or args.audio_format
            
            if args.optimized_batch:
                downloader.download_batch_optimized(
                    urls=urls,
                    quality=args.quality,
                    audio_only=args.audio_only,
                    output_format=output_format,
                    max_concurrent=args.max_concurrent
                )
            else:
                # Standard sequential batch download
                successful = 0
                for i, url in enumerate(urls, 1):
                    downloader.print_rich(f"\n{Icons.get('download')} [{i}/{len(urls)}] Processing: [bold blue]{url}[/bold blue]")
                    result = downloader.download_media(
                        url=url,
                        quality=args.quality,
                        audio_only=args.audio_only,
                        output_format=output_format,
                        custom_format=args.custom_format,
                        interactive=False,
                        add_metadata=args.embed_metadata or args.audio_only,
                        add_thumbnail=args.embed_thumbnail or args.audio_only
                    )
                    if result:
                        successful += 1
                
                downloader.print_rich(f"\n{Icons.get('stats')} Batch complete: [bold green]{successful}[/bold green]/[bold]{len(urls)}[/bold] successful")
            
            return
            
        except FileNotFoundError:
            downloader.print_rich(Messages.error(f"Batch file not found: {args.batch_file}"))
            return
        except Exception as e:
            downloader.print_rich(Messages.error(f"Error reading batch file: {e}"))
            return
    
    # Determine output format with priority: --format > --audio-format
    output_format = args.format or args.audio_format
    
    # Auto-enable metadata and thumbnails for audio files
    add_metadata = args.embed_metadata or args.audio_only
    add_thumbnail = args.embed_thumbnail or args.audio_only
    
    # Download single media with enhanced options
    downloader.download_media(
        url=args.url,
        quality=args.quality,
        audio_only=args.audio_only,
        output_format=output_format,
        custom_format=args.custom_format,
        interactive=use_interactive,
        add_metadata=add_metadata,
        add_thumbnail=add_thumbnail
    )

if __name__ == "__main__":    
    main()